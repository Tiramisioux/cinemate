diff --git a/src/module/config_loader.py b/src/module/config_loader.py
index e77ea193c47ff83c25000dd9995d12243f836265..c2ff35209e3fd3abfd2eae97b1742d6cc54dc94f 100644
--- a/src/module/config_loader.py
+++ b/src/module/config_loader.py
@@ -1,51 +1,51 @@
 import json
 import logging
 from pathlib import Path
 
 def load_settings(filename: str | Path) -> dict:
     """
     Load CineMate’s JSON configuration *and* guarantee that every section the
     code relies on is present with safe defaults.
 
     Return an always-valid settings dict – never None.
     """
     filename = Path(filename)
     try:
         with filename.open("r", encoding="utf-8") as fp:
             settings = json.load(fp)
     except FileNotFoundError:
         logging.warning("Settings file %s not found – using built-in defaults", filename)
         settings = {}
     except Exception as e:
         logging.error("Failed to load settings %s: %s – using built-in defaults", filename, e)
         settings = {}
 
     # ── top-level placeholders ───────────────────────────────────────────
     settings.setdefault("gpio_output",     {})
     settings.setdefault("arrays",          {})
-    settings.setdefault("settings",        {"light_hz": [50, 60]})
+    settings.setdefault("settings",        {"light_hz": [50, 60], "conform_frame_rate": 24})
     settings.setdefault("analog_controls", {})
     settings.setdefault("free_mode",       {
         "iso_free":       False,
         "shutter_a_free": False,
         "fps_free":       False,
         "wb_free":        False,
     })
     settings.setdefault("buttons",              [])
     settings.setdefault("two_way_switches",     [])
     settings.setdefault("rotary_encoders",      [])
     settings.setdefault("quad_rotary_encoders", {})
 
     # ── preview / zoom defaults ──────────────────────────────────────────
     preview_defaults = {
         "default_zoom": 1.0,
         "zoom_steps"  : [1.0, 1.5, 2.0],
     }
     preview_cfg = settings.setdefault("preview", {})
     for k, v in preview_defaults.items():
         preview_cfg.setdefault(k, v)
 
     # tidy up preview section
     preview_cfg["zoom_steps"] = sorted(set(preview_cfg["zoom_steps"]))
     if preview_cfg["default_zoom"] not in preview_cfg["zoom_steps"]:
         preview_cfg["default_zoom"] = preview_cfg["zoom_steps"][0]
diff --git a/src/module/redis_controller.py b/src/module/redis_controller.py
index 7a8b7a68270a05046e508cbb9ac100323b820b9d..3ea30de696d2f5977b5986a7ab7269714590df20 100644
--- a/src/module/redis_controller.py
+++ b/src/module/redis_controller.py
@@ -1,38 +1,38 @@
 # redis_controller.py – enhanced logging, suppress standalone BUFFER lines (2025‑06‑25)
 """Centralised Redis access + pub‑sub relay for CinePi.
 
 What’s new in this revision
 ---------------------------
 * Stand‑alone `buffer` updates are **never** logged anymore – independent
   of whether the caller uses the Enum or the raw string key.
 * The “BUFFER+RAM” suffix still accompanies every `last_dng_cam*` line so
   you keep full context while the camera is writing.
 """
 
 from __future__ import annotations
-import logging, threading, redis, psutil
+import logging, threading, redis, psutil, time
 from enum import Enum
 
 # ───────────────────────── parameter keys ────────────────────────────
 class ParameterKey(Enum):
     ANAMORPHIC_FACTOR = "anamorphic_factor"
     BIT_DEPTH         = "bit_depth"
     BUFFER            = "buffer"      # number of raw frames in RAM
     BUFFER_SIZE       = "buffer_size"  # RAM pool size for DNG encoder
     CAM_INIT          = "cam_init"
     CAMERAS           = "cameras"
     CG_RB             = "cg_rb"
     FILE_SIZE         = "file_size"
     FPS               = "fps"
     FPS_ACTUAL        = "fps_actual"
     FPS_LAST          = "fps_last"
     FPS_MAX           = "fps_max"
     FPS_USER          = "fps_user"
     FRAMECOUNT        = "framecount"
     GUI_LAYOUT        = "gui_layout"
     HEIGHT            = "height"
     IR_FILTER         = "ir_filter"
     IS_BUFFERING      = "is_buffering"
     IS_MOUNTED        = "is_mounted"
     IS_RECORDING      = "is_recording"
     IS_WRITING        = "is_writing"
@@ -41,111 +41,157 @@ class ParameterKey(Enum):
     ISO               = "iso"
     LORES_HEIGHT      = "lores_height"
     LORES_WIDTH       = "lores_width"
     PI_MODEL          = "pi_model"
     REC               = "rec"
     SENSOR            = "sensor"
     SENSOR_MODE       = "sensor_mode"
     SHUTTER_A         = "shutter_a"
 
     SPACE_LEFT        = "space_left"
     STORAGE_TYPE      = "storage_type"
     TRIGGER_MODE      = "trigger_mode"
     WB                = "wb"
     WB_USER           = "wb_user"
     WIDTH             = "width"
     MEMORY_ALERT      = "memory_alert"
     SHUTTER_A_SYNC_MODE = 'shutter_a_sync_mode'
     SHUTTER_A_NOM       = 'shutter_angle_nom'
     SHUTTER_A_ACTUAL    = 'shutter_angle_actual'
     SHUTTER_A_TRANSIENT = 'shutter_angle_transient'
     EXPOSURE_TIME       = 'exposure_time'
     LAST_DNG_CAM1       = "last_dng_cam1"
     LAST_DNG_CAM0       = "last_dng_cam0"
     
     ZOOM                = "zoom"  # digital zoom factor for streams 0 & 2
-    WRITE_SPEED_TO_DRIVE = "write_speed_to_drive"    
+    WRITE_SPEED_TO_DRIVE = "write_speed_to_drive"
+    RECORDING_TIME       = "recording_time"
 
 
 # ────────────────────────── tiny pub‑sub helper ──────────────────────
 class Event:
     def __init__(self):
         self._handlers = []
     def subscribe(self, fn):
         self._handlers.append(fn)
     def emit(self, data=None):
         for fn in self._handlers:
             fn(data)
 
 # ────────────────────────── main controller class ────────────────────
 class RedisController:
 
-    def __init__(self, host="localhost", port=6379, db=0, channel="cp_controls"):
+    def __init__(self, host="localhost", port=6379, db=0, channel="cp_controls", conform_frame_rate: int = 24):
         self.r      = redis.StrictRedis(host=host, port=port, db=db)
         self.ps     = self.r.pubsub(); self.ps.subscribe(channel)
         self.lock   = threading.Lock()
         self.cache  = {}
         self.local_updates: set[str] = set()
 
         self.redis_parameter_changed = Event()
 
+        self.conform_frame_rate = conform_frame_rate
+        self.recording_start_time: float | None = None
+        self._rec_timer_stop = threading.Event()
+        self._rec_timer_thread: threading.Thread | None = None
+
         self._prime_cache()
         self._thread = threading.Thread(target=self._listen, daemon=True)
         self._thread.start()
 
     # ─────────────────────── initial cache fill ─────────────────────
     def _prime_cache(self):
         for key in self.r.keys("*"):
             val = self.r.get(key) or b""
             self.cache[key.decode()] = val.decode(errors="replace")
         logging.info("RedisController cache primed with %d keys", len(self.cache))
 
     # ─────────────────────── background listener ────────────────────
     def _listen(self):
         for msg in self.ps.listen():
             if msg["type"] != "message":
                 continue
             key = msg["data"].decode()
             with self.lock:
                 # suppress echo of own writes
                 if key in self.local_updates:
                     self.local_updates.remove(key)
                 value = (self.r.get(key) or b"").decode()
                 self.cache[key] = value
+
+            if key == ParameterKey.REC.value:
+                if value == "1":
+                    self._start_recording_timer()
+                else:
+                    self._stop_recording_timer()
             # notify subscribers – no log spam here
             if key != ParameterKey.FPS_ACTUAL.value:
                 self.redis_parameter_changed.emit({"key": key, "value": value})
 
     # ───────────────────────── public helpers ───────────────────────
     def get_value(self, key, default=None):
         with self.lock:
             return self.cache.get(key, default)
 
     def set_value(self, key, value):
         """Write key, publish, update cache, emit single consolidated log."""
         # normalise key to plain string for comparisons / logging
         key_name = key.value if isinstance(key, ParameterKey) else str(key)
 
         with self.lock:
             if str(self.cache.get(key_name)) == str(value):
                 return  # unchanged
             self.r.set(key_name, value)
             self.r.publish("cp_controls", key_name)
             self.cache[key_name] = str(value)
             self.local_updates.add(key_name)
 
         # ─── enhanced logging ───────────────────────────────────────
         if key_name.startswith("last_dng_cam"):
             ram = psutil.virtual_memory().percent
             logging.info(
                 f"Changed value: {key_name} = {value} ┃RAM: {ram:.0f}%"
             )
         elif key_name not in (ParameterKey.FPS_ACTUAL.value, ParameterKey.BUFFER.value):
             # skip standalone BUFFER, & FPS_ACTUAL noise
             logging.info(f"Changed value: {key_name} = {value}")
 
         # immediate local notification
         self.redis_parameter_changed.emit({"key": key_name, "value": str(value)})
 
+    # ─────────────────────── recording timer helpers ─────────────────────
+    def _format_timecode(self, elapsed: float) -> str:
+        rate = self.conform_frame_rate
+        total_frames = int(elapsed * rate)
+        frames = total_frames % rate
+        total_seconds = total_frames // rate
+        seconds = total_seconds % 60
+        minutes = (total_seconds // 60) % 60
+        hours = total_seconds // 3600
+        return f"{hours:02d}:{minutes:02d}:{seconds:02d}:{frames:02d}"
+
+    def _run_recording_timer(self):
+        while not self._rec_timer_stop.is_set():
+            if self.recording_start_time is None:
+                break
+            elapsed = time.time() - self.recording_start_time
+            tc = self._format_timecode(elapsed)
+            self.set_value(ParameterKey.RECORDING_TIME, tc)
+            self._rec_timer_stop.wait(1 / self.conform_frame_rate)
+
+    def _start_recording_timer(self):
+        self._stop_recording_timer()
+        self.recording_start_time = time.time()
+        self.set_value(ParameterKey.RECORDING_TIME, "00:00:00:00")
+        self._rec_timer_stop.clear()
+        self._rec_timer_thread = threading.Thread(target=self._run_recording_timer, daemon=True)
+        self._rec_timer_thread.start()
+
+    def _stop_recording_timer(self):
+        self._rec_timer_stop.set()
+        if self._rec_timer_thread and self._rec_timer_thread.is_alive():
+            self._rec_timer_thread.join(timeout=0.5)
+        self._rec_timer_thread = None
+
     # optional helper -------------------------------------------------
     def stop_listener(self):
         self.ps.unsubscribe(); self.ps.close(); self._thread.join(timeout=1)
diff --git a/src/settings.json b/src/settings.json
index b7c05df05f78ba32f41f2ad4de4d3d5cd3a77453..478144b20f2a13c2252754046407d91d5b5f9f9e 100644
--- a/src/settings.json
+++ b/src/settings.json
@@ -31,51 +31,52 @@
   },
 
   "preview": {
     "default_zoom": 1.0,
     "zoom_steps":   [1.0, 1.5, 2.0]
   },
 
   "anamorphic_preview": {
       "default_anamorphic_factor": 1,
     "anamorphic_steps": [1, 1.33, 2.0]
   },
 
   "gpio_output": {
     "pwm_pin": 19,
     "rec_out_pin": [6, 21]
   },
   
   "arrays": {
     "iso_steps": [100, 200, 400, 640, 800, 1200, 1600, 2500, 3200],
     "shutter_a_steps": [1, 45, 90, 135, 172.8, 180, 225, 270, 315, 346.6, 360],
     "fps_steps": [1, 2, 4, 8, 12, 16, 18, 24, 25, 33, 40, 50],
     "wb_steps": [3200, 4400, 5600]
   },
   
   "settings": {
-    "light_hz": [50, 60]
+    "light_hz": [50, 60],
+    "conform_frame_rate": 24
   },
   
   "analog_controls": {
     "iso_pot": 0,
     "shutter_a_pot": 2,
     "fps_pot": 4,
     "wb_pot": 6
   },
   
   "free_mode": {
     "iso_free": false,
     "shutter_a_free": false,
     "fps_free": true,
     "wb_free": false
   },
 
 
   
 "buttons": [
     {
       "pin": 5,
       "pull_up": true,
       "debounce_time": 0.1,
       "press_action": {"method": "rec"}
     },
EOF
