{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cinemate Docs # Welcome to the Cinemate project - an open-source boiler plate for building your own digital cinema camera using a Raspberry Pi 5. It combines a lightweight Python interface with the CinePi\u2011raw recorder by Csaba Nagy for capturing 12\u2011bit CinemaDNG footage. To begin, follow the steps in Quick start . Later chapters explain how to customise the system to tailor Cinemate to your needs. For sharing your build with others, inspiration and discussion, make sure to join the CinePi Discord .","title":"Home"},{"location":"#cinemate-docs","text":"Welcome to the Cinemate project - an open-source boiler plate for building your own digital cinema camera using a Raspberry Pi 5. It combines a lightweight Python interface with the CinePi\u2011raw recorder by Csaba Nagy for capturing 12\u2011bit CinemaDNG footage. To begin, follow the steps in Quick start . Later chapters explain how to customise the system to tailor Cinemate to your needs. For sharing your build with others, inspiration and discussion, make sure to join the CinePi Discord .","title":"Cinemate Docs"},{"location":"acknowledgments/","text":"Acknowledgements # The Cinemate stack is built on top of several open-source projects. Special thanks to all authors! CinePi-raw \u2013 Csaba Nagy IMX585 and IMX283 drivers \u2013 Will Whang libcamera \u2013 Ideas on board cpp-mjpeg-streamer \u2013 Nadjieb Mohammadi lgpio \u2013 Joan Also thanks to Simon at Altcinecam for support and assistance! Get your sensors and CFE Hats here: https://www.tindie.com/stores/will123321/ Supporting the project # kofiwidget2.init('Support Cinemate on Ko-fi', '#72a4f2', 'G2G21IM9RO'); kofiwidget2.draw();","title":"Acknowledgements"},{"location":"acknowledgments/#acknowledgements","text":"The Cinemate stack is built on top of several open-source projects. Special thanks to all authors! CinePi-raw \u2013 Csaba Nagy IMX585 and IMX283 drivers \u2013 Will Whang libcamera \u2013 Ideas on board cpp-mjpeg-streamer \u2013 Nadjieb Mohammadi lgpio \u2013 Joan Also thanks to Simon at Altcinecam for support and assistance! Get your sensors and CFE Hats here: https://www.tindie.com/stores/will123321/","title":"Acknowledgements"},{"location":"acknowledgments/#supporting-the-project","text":"kofiwidget2.init('Support Cinemate on Ko-fi', '#72a4f2', 'G2G21IM9RO'); kofiwidget2.draw();","title":"Supporting the project"},{"location":"audio-recording/","text":"Audio recording (experimental) # Cinemate records audio alongside the image sequence. Support is currently limited to a few USB microphones with hard coded configurations: - R\u00d8DE VideoMic NTG \u2013 recorded in stereo at 24\u2011bit/48 kHz. - USB PnP microphones \u2013 recorded in mono at 16\u2011bit/48 kHz. Other class\u2011compliant USB microphones are now detected automatically by probing the ALSA hardware devices reported by arecord -l . Cinemate will fall back to using the matching USB device (via plughw:<card>,<device> ) if the mic_24bit or mic_16bit aliases are not available. Audio is written as .wav files into the same folder as the .dng frames. The implementation is still experimental and audio/video synchronization needs further investigation. .asoundrc Setup # For dsnoop support, create a ~/.asoundrc in home directory: nano ~/.asoundrc Paste this into the file: pcm.dsnoop_24bit { type dsnoop ipc_key 2048 slave { pcm \"hw:Device,0\" channels 2 rate 48000 format S24_3LE period_size 1024 buffer_size 4096 } } pcm.dsnoop_16bit { type dsnoop ipc_key 2049 slave { pcm \"hw:Device,0\" channels 1 rate 48000 format S16_LE period_size 1024 buffer_size 4096 } } pcm.mic_24bit { type plug slave.pcm \"dsnoop_24bit\" } pcm.mic_16bit { type plug slave.pcm \"dsnoop_16bit\" } Exit nano editor using ctrl+x.","title":"Audio recording"},{"location":"audio-recording/#audio-recording-experimental","text":"Cinemate records audio alongside the image sequence. Support is currently limited to a few USB microphones with hard coded configurations: - R\u00d8DE VideoMic NTG \u2013 recorded in stereo at 24\u2011bit/48 kHz. - USB PnP microphones \u2013 recorded in mono at 16\u2011bit/48 kHz. Other class\u2011compliant USB microphones are now detected automatically by probing the ALSA hardware devices reported by arecord -l . Cinemate will fall back to using the matching USB device (via plughw:<card>,<device> ) if the mic_24bit or mic_16bit aliases are not available. Audio is written as .wav files into the same folder as the .dng frames. The implementation is still experimental and audio/video synchronization needs further investigation.","title":"Audio recording (experimental)"},{"location":"audio-recording/#asoundrc-setup","text":"For dsnoop support, create a ~/.asoundrc in home directory: nano ~/.asoundrc Paste this into the file: pcm.dsnoop_24bit { type dsnoop ipc_key 2048 slave { pcm \"hw:Device,0\" channels 2 rate 48000 format S24_3LE period_size 1024 buffer_size 4096 } } pcm.dsnoop_16bit { type dsnoop ipc_key 2049 slave { pcm \"hw:Device,0\" channels 1 rate 48000 format S16_LE period_size 1024 buffer_size 4096 } } pcm.mic_24bit { type plug slave.pcm \"dsnoop_24bit\" } pcm.mic_16bit { type plug slave.pcm \"dsnoop_16bit\" } Exit nano editor using ctrl+x.","title":".asoundrc Setup"},{"location":"backing-up-sd-card/","text":"Backing up the SD card # To create a compressed image using PiShrink # sudo bash -Eeuo pipefail -c ' # Timestamp like 2025-07-19_19-38-33 ts=$(date +%F_%H-%M-%S) # Paths on /media/RAW raw=\"/media/RAW/Cinemate_${ts}.img\" # working image final=\"/media/RAW/cinemate_${ts}.img.xz\" # desired end-result # 1 \u2500 Image the SD-card (pads bad blocks, keeps sparsity) dd if=/dev/mmcblk0 of=\"$raw\" \\ bs=4M conv=noerror,sync,sparse status=progress # 2 \u2500 Shrink + parallel-xz compress **in place** /usr/local/bin/pishrink.sh -s -v -Z -a \"$raw\" # 3 \u2500 Rename the freshly-made .xz to the lowercase style you want mv \"${raw}.xz\" \"$final\" # 4 \u2500 Remove the now-unused raw image rm -f \"$raw\" ' Check the name of the resulting file # cd /media/RAW ls Your output will look something like this: The file ending with .img.xz is your compressed file. To copy the file to your desktop computer: # # From the desktop computers terminal scp pi@cinepi.local:/media/RAW/cinemate_2025-07-29_13-37-37.img.xz ~/Downloads/ # Change the file name to that of you image file. When unpacking the image, it will inflate to the smallest possible size, even if it was made from a larger SD card. So an Cinemate image created from a 64 GB SD card will inflate to only about 6 GB, allowing for flashing it to SD cards down to 8 GB.","title":"Backing up the SD card"},{"location":"backing-up-sd-card/#backing-up-the-sd-card","text":"","title":"Backing up the SD card"},{"location":"backing-up-sd-card/#to-create-a-compressed-image-using-pishrink","text":"sudo bash -Eeuo pipefail -c ' # Timestamp like 2025-07-19_19-38-33 ts=$(date +%F_%H-%M-%S) # Paths on /media/RAW raw=\"/media/RAW/Cinemate_${ts}.img\" # working image final=\"/media/RAW/cinemate_${ts}.img.xz\" # desired end-result # 1 \u2500 Image the SD-card (pads bad blocks, keeps sparsity) dd if=/dev/mmcblk0 of=\"$raw\" \\ bs=4M conv=noerror,sync,sparse status=progress # 2 \u2500 Shrink + parallel-xz compress **in place** /usr/local/bin/pishrink.sh -s -v -Z -a \"$raw\" # 3 \u2500 Rename the freshly-made .xz to the lowercase style you want mv \"${raw}.xz\" \"$final\" # 4 \u2500 Remove the now-unused raw image rm -f \"$raw\" '","title":"To create a compressed image using PiShrink"},{"location":"backing-up-sd-card/#check-the-name-of-the-resulting-file","text":"cd /media/RAW ls Your output will look something like this: The file ending with .img.xz is your compressed file.","title":"Check the name of the resulting file"},{"location":"backing-up-sd-card/#to-copy-the-file-to-your-desktop-computer","text":"# From the desktop computers terminal scp pi@cinepi.local:/media/RAW/cinemate_2025-07-29_13-37-37.img.xz ~/Downloads/ # Change the file name to that of you image file. When unpacking the image, it will inflate to the smallest possible size, even if it was made from a larger SD card. So an Cinemate image created from a 64 GB SD card will inflate to only about 6 GB, allowing for flashing it to SD cards down to 8 GB.","title":"To copy the file to your desktop computer:"},{"location":"bare-bones-build/","text":"","title":"Bare bones build"},{"location":"brick/","text":"TBA","title":"Brick"},{"location":"cinepi-multi/","text":"How Cinemate launches cinepi-raw # cinemate/src/module/cinepi_multi.py starts one cinepi-raw process per connected camera. It takes camera information cinemate/src/module/sensor_detect.py and user settings from cinemate/src/module/settings.json to build the command and command-line flags passed to cinepi-raw . Detecting Cameras # When CineMate starts, cinemate/src/module/cinepi_multi.py/CinePiManager runs the cli command cinepi-raw --list-cameras . The manager parses this output and stores resolution modes for each attached camera. Tip You can narrow down the list of selectable modes via the resolutions section in settings.json . Only modes whose width falls into one of your chosen K categories and whose bit depth matches will be shown. Custom driver modes not reported by cinepi-raw can also be added here. Building the cinepi-raw Command # For each detected camera the manager creates a CinePiProcess . The _build_args() method constructs a list of command-line flags for cinepi-raw . Here is an example of the resulting command: cinepi-raw --camera 0 --mode 2028 :1080:12:U \\ --width 2028 --height 1080 \\ --lores-width 1280 --lores-height 720 \\ --hdmi-port 0 --rotation 0 --hflip 0 --vflip 0 \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json Note If you want to change how arguments are built, look inside the _build_args() method. The rest of the file deals with process management, log forwarding and readiness checks.","title":"How Cinemate launches cinepi-raw"},{"location":"cinepi-multi/#how-cinemate-launches-cinepi-raw","text":"cinemate/src/module/cinepi_multi.py starts one cinepi-raw process per connected camera. It takes camera information cinemate/src/module/sensor_detect.py and user settings from cinemate/src/module/settings.json to build the command and command-line flags passed to cinepi-raw .","title":"How Cinemate launches cinepi-raw"},{"location":"cinepi-multi/#detecting-cameras","text":"When CineMate starts, cinemate/src/module/cinepi_multi.py/CinePiManager runs the cli command cinepi-raw --list-cameras . The manager parses this output and stores resolution modes for each attached camera. Tip You can narrow down the list of selectable modes via the resolutions section in settings.json . Only modes whose width falls into one of your chosen K categories and whose bit depth matches will be shown. Custom driver modes not reported by cinepi-raw can also be added here.","title":"Detecting Cameras"},{"location":"cinepi-multi/#building-the-cinepi-raw-command","text":"For each detected camera the manager creates a CinePiProcess . The _build_args() method constructs a list of command-line flags for cinepi-raw . Here is an example of the resulting command: cinepi-raw --camera 0 --mode 2028 :1080:12:U \\ --width 2028 --height 1080 \\ --lores-width 1280 --lores-height 720 \\ --hdmi-port 0 --rotation 0 --hflip 0 --vflip 0 \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json Note If you want to change how arguments are built, look inside the _build_args() method. The rest of the file deals with process management, log forwarding and readiness checks.","title":"Building the cinepi-raw Command"},{"location":"cli-commands/","text":"Commands reference # Cinemate doesn\u2019t use a real shell parser. Instead, a background thread reads simple text commands from SSH or the serial port and calls the corresponding controller methods. Note if you have Cinemate already running, for example by running the preinstalled image file, you first need to stop the autostarted instance in order and manually start Cinemate in order to use the Cinemate CLI: cd cinemate # change directory to cinemate folder make stop # stop the autostarted instance cinemate # start cinemate manually Commands without an explicit argument will toggle the current state when possible (e.g. set fps lock flips the lock; set fps lock 1 forces it on). All of the commands below can be easily mapped to GPIO buttons rotary encoders and other input devices. See this section for how to configure the settings file. Command Argument Example Function rec / stop [s <seconds>] \\| [f <frames>] rec s 10 Toggle recording or schedule an automatic stop after a timed duration or frame count set iso <value> int set iso 800 Set ISO to nearest allowed step inc iso / dec iso - Step ISO up or down set shutter a <angle> float set shutter a 180 Set actual shutter angle (snaps unless free/sync) inc shutter a / dec shutter a - Cycle through shutter angles set shutter a nom <angle> float set shutter a nom 180 Set nominal shutter angle for motion blur inc shutter a nom / dec shutter a nom - Step the nominal shutter angle set fps <value> float set fps 24 Change frame rate (snaps unless free) inc fps / dec fps - Step through FPS list set wb [<Kelvin>] int or none set wb 5600 Set white balance or cycle presets inc wb / dec wb - Cycle white balance steps set resolution [<mode>] int or none set resolution 2 Apply or cycle sensor mode set anamorphic factor [<float>] float or none set anamorphic factor 1.33 Set or toggle anamorphic stretch set zoom [<float>] float or none set zoom 2 Change digital zoom; omit to cycle inc zoom / dec zoom - Step preview zoom factor mount / unmount - Mount or unmount external storage toggle mount - Mount if not mounted, otherwise unmount erase - erase Delete every clip on the mounted RAW volume without reformatting format [ext4\\|ntfs] format ntfs Reformat the RAW drive (defaults to ext4) and remount it storage preroll - storage preroll Run the storage warm-up recording that prepares the media time - Show system and RTC time set rtc time - Copy system time to the RTC space - Report remaining SSD space get - Print all current settings (Redis keys in cp_controls channel) set shutter a sync [0/1] 0/1 or none set shutter a sync 1 Enable exposure sync mode set iso lock [0/1] 0/1 or none Lock or unlock ISO setting set shutter a nom lock [0/1] 0/1 or none set shutter a nom lock Lock or unlock nominal shutter set shutter a nom fps lock [0/1] 0/1 or none set shutter a nom fps lock 1 Lock nominal shutter and FPS together set fps lock [0/1] 0/1 or none set fps lock 1 Lock or unlock the frame rate set all lock [0/1] 0/1 or none set all lock 0 Toggle all exposure locks at once set fps double [0/1] 0/1 or none Instant or toggled 2\u00d7 FPS mode reboot / shutdown - Safely reboot or halt the Pi restart camera - ` Restart the libcamera pipeline restart cinemate - Restart the Cinemate process set iso free [0/1] 0/1 or none set iso free 1 Allow any ISO instead of presets set shutter a free [0/1] 0/1 or none set shutter a free 0 Allow any shutter angle set fps free [0/1] 0/1 or none set fps free 1 Allow any FPS set wb free [0/1] 0/1 or none set wb free Allow any white balance set filter <0/1> 0/1 set filter 1 Toggle IR-cut filter (IMX585) Timed recording shortcuts # The rec command now accepts timed modes so you can walk away from the camera while it captures a precisely bounded take. rec s <seconds> stops the recording after the requested duration. Short forms such as sec , secs and seconds are also accepted. rec f <frames> converts the requested frame count to seconds using the current FPS and schedules the stop for you. You can type frame or frames instead of f . If recording is not already running, the CLI starts it automatically before arming the timer. An invalid or zero value is ignored so you cannot accidentally stop a clip immediately.\u3010F:src/module/cli_commands.py\u2020L205-L237\u3011\u3010F:src/module/cinepi_controller.py\u2020L533-L591\u3011 Storage maintenance commands # Two new commands simplify preparing removable media directly from the Cinemate CLI: erase empties the mounted RAW volume without touching the filesystem structure so you can clear cards quickly between takes. format [ext4|ntfs] reformats the drive with the chosen filesystem ( ext4 by default), remounts it and refreshes the free-space monitor. The helper tolerates the common ex4 typo and refuses unsupported targets so you do not accidentally create an unusable volume. Both actions require the RAW drive to be mounted; otherwise the CLI reports an error and leaves the media untouched. Storage pre-roll warm-up # storage preroll triggers the automatic warm-up clip that Cinemate normally runs on startup or when you mount new storage. During the pre-roll, Cinemate temporarily drives the sensor at its maximum FPS, records a short burst, waits for buffers to flush and removes the test clip so the media is primed for the next real take.\u3010F:src/module/storage_preroll.py\u2020L40-L175\u3011 See Storage pre-roll warm-up for a detailed walkthrough of the workflow and tips on when to run it manually.","title":"Cinemate terminal commands"},{"location":"cli-commands/#commands-reference","text":"Cinemate doesn\u2019t use a real shell parser. Instead, a background thread reads simple text commands from SSH or the serial port and calls the corresponding controller methods. Note if you have Cinemate already running, for example by running the preinstalled image file, you first need to stop the autostarted instance in order and manually start Cinemate in order to use the Cinemate CLI: cd cinemate # change directory to cinemate folder make stop # stop the autostarted instance cinemate # start cinemate manually Commands without an explicit argument will toggle the current state when possible (e.g. set fps lock flips the lock; set fps lock 1 forces it on). All of the commands below can be easily mapped to GPIO buttons rotary encoders and other input devices. See this section for how to configure the settings file. Command Argument Example Function rec / stop [s <seconds>] \\| [f <frames>] rec s 10 Toggle recording or schedule an automatic stop after a timed duration or frame count set iso <value> int set iso 800 Set ISO to nearest allowed step inc iso / dec iso - Step ISO up or down set shutter a <angle> float set shutter a 180 Set actual shutter angle (snaps unless free/sync) inc shutter a / dec shutter a - Cycle through shutter angles set shutter a nom <angle> float set shutter a nom 180 Set nominal shutter angle for motion blur inc shutter a nom / dec shutter a nom - Step the nominal shutter angle set fps <value> float set fps 24 Change frame rate (snaps unless free) inc fps / dec fps - Step through FPS list set wb [<Kelvin>] int or none set wb 5600 Set white balance or cycle presets inc wb / dec wb - Cycle white balance steps set resolution [<mode>] int or none set resolution 2 Apply or cycle sensor mode set anamorphic factor [<float>] float or none set anamorphic factor 1.33 Set or toggle anamorphic stretch set zoom [<float>] float or none set zoom 2 Change digital zoom; omit to cycle inc zoom / dec zoom - Step preview zoom factor mount / unmount - Mount or unmount external storage toggle mount - Mount if not mounted, otherwise unmount erase - erase Delete every clip on the mounted RAW volume without reformatting format [ext4\\|ntfs] format ntfs Reformat the RAW drive (defaults to ext4) and remount it storage preroll - storage preroll Run the storage warm-up recording that prepares the media time - Show system and RTC time set rtc time - Copy system time to the RTC space - Report remaining SSD space get - Print all current settings (Redis keys in cp_controls channel) set shutter a sync [0/1] 0/1 or none set shutter a sync 1 Enable exposure sync mode set iso lock [0/1] 0/1 or none Lock or unlock ISO setting set shutter a nom lock [0/1] 0/1 or none set shutter a nom lock Lock or unlock nominal shutter set shutter a nom fps lock [0/1] 0/1 or none set shutter a nom fps lock 1 Lock nominal shutter and FPS together set fps lock [0/1] 0/1 or none set fps lock 1 Lock or unlock the frame rate set all lock [0/1] 0/1 or none set all lock 0 Toggle all exposure locks at once set fps double [0/1] 0/1 or none Instant or toggled 2\u00d7 FPS mode reboot / shutdown - Safely reboot or halt the Pi restart camera - ` Restart the libcamera pipeline restart cinemate - Restart the Cinemate process set iso free [0/1] 0/1 or none set iso free 1 Allow any ISO instead of presets set shutter a free [0/1] 0/1 or none set shutter a free 0 Allow any shutter angle set fps free [0/1] 0/1 or none set fps free 1 Allow any FPS set wb free [0/1] 0/1 or none set wb free Allow any white balance set filter <0/1> 0/1 set filter 1 Toggle IR-cut filter (IMX585)","title":"Commands reference"},{"location":"cli-commands/#timed-recording-shortcuts","text":"The rec command now accepts timed modes so you can walk away from the camera while it captures a precisely bounded take. rec s <seconds> stops the recording after the requested duration. Short forms such as sec , secs and seconds are also accepted. rec f <frames> converts the requested frame count to seconds using the current FPS and schedules the stop for you. You can type frame or frames instead of f . If recording is not already running, the CLI starts it automatically before arming the timer. An invalid or zero value is ignored so you cannot accidentally stop a clip immediately.\u3010F:src/module/cli_commands.py\u2020L205-L237\u3011\u3010F:src/module/cinepi_controller.py\u2020L533-L591\u3011","title":"Timed recording shortcuts"},{"location":"cli-commands/#storage-maintenance-commands","text":"Two new commands simplify preparing removable media directly from the Cinemate CLI: erase empties the mounted RAW volume without touching the filesystem structure so you can clear cards quickly between takes. format [ext4|ntfs] reformats the drive with the chosen filesystem ( ext4 by default), remounts it and refreshes the free-space monitor. The helper tolerates the common ex4 typo and refuses unsupported targets so you do not accidentally create an unusable volume. Both actions require the RAW drive to be mounted; otherwise the CLI reports an error and leaves the media untouched.","title":"Storage maintenance commands"},{"location":"cli-commands/#storage-pre-roll-warm-up","text":"storage preroll triggers the automatic warm-up clip that Cinemate normally runs on startup or when you mount new storage. During the pre-roll, Cinemate temporarily drives the sensor at its maximum FPS, records a short burst, waits for buffers to flush and removes the test clip so the media is primed for the next real take.\u3010F:src/module/storage_preroll.py\u2020L40-L175\u3011 See Storage pre-roll warm-up for a detailed walkthrough of the workflow and tips on when to run it manually.","title":"Storage pre-roll warm-up"},{"location":"cli-user-guide/","text":"Using CinePi-RAW from the terminal # Here is how you can operate CinePi-raw from the command line. Checking available options # Before running the program you can view all command\u2011line flags with: cinepi-raw -h This prints a long list of options supported by the application. It includes the standard parameters from rpicam-apps (such as resolution and exposure settings) plus additional flags specific to the Cinemate. Camera modes # CinePi-raw uses Libcamera to talk to your Raspberry Pi camera module. Each sensor supports one or more modes , which define the resolution and bit depth of the RAW images that the sensor can produce. A mode is written as: --mode 2028:1080:12:U width and height select the active pixel area of the sensor. bit-depth is usually 12 or 16 bits per pixel. packing can be P for packed or U for unpacked data. The mode must match the sensor you are using. For example, an IMX477 camera can run at 4056:3040:12 (full sensor) or at smaller cropped resolutions. When specifying a mode you typically also set the output --width and --height which control the size of the image written to disk. These can be equal to the mode values or smaller when scaling is applied. On the Pi 5, the cinepi-raw flag for HQ sensor is --mode 2028:1080:12:U . On the Pi 4 it should read --mode 2028:1080:12:P . Low\u2011resolution (lores) stream # --lores-width 1280 --lores-height 720 CinePi-raw can produce a secondary low\u2011resolution stream alongside the full\u2011resolution RAW frames. Preview window # By default the program opens an HDMI preview so you can see what the camera captures. The size and position of this window are controlled with: -p 0,30,1920,1020 This positions the preview 30 pixels from the top of the screen with a 1920\u00d71020 window. Tuning file # -- tuning - file / home / pi / libcamera / src / ipa / rpi / pisp / data / { model_key } . json Describes the camera\u2019s colour and lens characteristics. Point to a file supplied with Libcamera (for example /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json for the HQ camera) Post processing # --post-process-file /home/pi/post-processing.json For cinepi-raw, this file defines the port used by cpp-mjpeg-streamer (default cinepi.local:8000) If you have more than one camera connected to the Pi, and activated in boot/firmware/config.txt , the camera commected to physical cam0 will use /home/pi/post-processing0.json and the camera connected to cam1 will use /home/pi/post-processing1.json . Cinemate\u2011specific flags # The CineMate fork introduces several extra options: Flag Argument Description --cam-port cam0 | cam1 Select which CSI camera port to use. --hdmi-port 0 | 1 | -1 Choose the HDMI connector for the preview ( 0 = HDMI-0, 1 = HDMI-1, -1 = auto-detect). --same-hdmi (none) Force both capture and controller GUI to share the same HDMI output. --keep16 true | false Save full 16-bit DNGs instead of 12-bit packed files. At this moment though, Cinemate is 12bit only. The flag is for future updates of the IMX585 16bit clear HDR modes. Example commands # Below are sample commands for different sensors and modes. IMX477 (12\u2011bit, full width) # cinepi-raw --mode 4056 :2160:12 --width 4056 --height 2160 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json \\ IMX585 (12\u2011bit unpacked) # cinepi-raw --mode 1928 :1090:12:U --width 1928 --height 1090 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ Now, with an SSH shell running redis-cli you should be able to capture RAW footage from the command line! redis-cli > set is_recording 1 > publish cp_controls is_recording","title":"CinePi RAW terminal commands"},{"location":"cli-user-guide/#using-cinepi-raw-from-the-terminal","text":"Here is how you can operate CinePi-raw from the command line.","title":"Using CinePi-RAW from the terminal"},{"location":"cli-user-guide/#checking-available-options","text":"Before running the program you can view all command\u2011line flags with: cinepi-raw -h This prints a long list of options supported by the application. It includes the standard parameters from rpicam-apps (such as resolution and exposure settings) plus additional flags specific to the Cinemate.","title":"Checking available options"},{"location":"cli-user-guide/#camera-modes","text":"CinePi-raw uses Libcamera to talk to your Raspberry Pi camera module. Each sensor supports one or more modes , which define the resolution and bit depth of the RAW images that the sensor can produce. A mode is written as: --mode 2028:1080:12:U width and height select the active pixel area of the sensor. bit-depth is usually 12 or 16 bits per pixel. packing can be P for packed or U for unpacked data. The mode must match the sensor you are using. For example, an IMX477 camera can run at 4056:3040:12 (full sensor) or at smaller cropped resolutions. When specifying a mode you typically also set the output --width and --height which control the size of the image written to disk. These can be equal to the mode values or smaller when scaling is applied. On the Pi 5, the cinepi-raw flag for HQ sensor is --mode 2028:1080:12:U . On the Pi 4 it should read --mode 2028:1080:12:P .","title":"Camera modes"},{"location":"cli-user-guide/#lowresolution-lores-stream","text":"--lores-width 1280 --lores-height 720 CinePi-raw can produce a secondary low\u2011resolution stream alongside the full\u2011resolution RAW frames.","title":"Low\u2011resolution (lores) stream"},{"location":"cli-user-guide/#preview-window","text":"By default the program opens an HDMI preview so you can see what the camera captures. The size and position of this window are controlled with: -p 0,30,1920,1020 This positions the preview 30 pixels from the top of the screen with a 1920\u00d71020 window.","title":"Preview window"},{"location":"cli-user-guide/#tuning-file","text":"-- tuning - file / home / pi / libcamera / src / ipa / rpi / pisp / data / { model_key } . json Describes the camera\u2019s colour and lens characteristics. Point to a file supplied with Libcamera (for example /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json for the HQ camera)","title":"Tuning file"},{"location":"cli-user-guide/#post-processing","text":"--post-process-file /home/pi/post-processing.json For cinepi-raw, this file defines the port used by cpp-mjpeg-streamer (default cinepi.local:8000) If you have more than one camera connected to the Pi, and activated in boot/firmware/config.txt , the camera commected to physical cam0 will use /home/pi/post-processing0.json and the camera connected to cam1 will use /home/pi/post-processing1.json .","title":"Post processing"},{"location":"cli-user-guide/#cinematespecific-flags","text":"The CineMate fork introduces several extra options: Flag Argument Description --cam-port cam0 | cam1 Select which CSI camera port to use. --hdmi-port 0 | 1 | -1 Choose the HDMI connector for the preview ( 0 = HDMI-0, 1 = HDMI-1, -1 = auto-detect). --same-hdmi (none) Force both capture and controller GUI to share the same HDMI output. --keep16 true | false Save full 16-bit DNGs instead of 12-bit packed files. At this moment though, Cinemate is 12bit only. The flag is for future updates of the IMX585 16bit clear HDR modes.","title":"Cinemate\u2011specific flags"},{"location":"cli-user-guide/#example-commands","text":"Below are sample commands for different sensors and modes.","title":"Example commands"},{"location":"cli-user-guide/#imx477-12bit-full-width","text":"cinepi-raw --mode 4056 :2160:12 --width 4056 --height 2160 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json \\","title":"IMX477 (12\u2011bit, full width)"},{"location":"cli-user-guide/#imx585-12bit-unpacked","text":"cinepi-raw --mode 1928 :1090:12:U --width 1928 --height 1090 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ Now, with an SSH shell running redis-cli you should be able to capture RAW footage from the command line! redis-cli > set is_recording 1 > publish cp_controls is_recording","title":"IMX585 (12\u2011bit unpacked)"},{"location":"compiling-cinepi-raw/","text":"Recompiling cinepi-raw # Compiling cinepi-raw For easy later rebuilding and installation of cinepi-raw you can create the file compile-raw.sh. nano compile-raw.sh Paste this into the file sudo meson install -C build Exit by pressing Ctrl+C Make it exectutable: sudo chmod +x compile-raw.sh Now, from the same folder, to build and install cinepi-raw: ./compile-raw.sh","title":"Recompiling cinepi-raw"},{"location":"compiling-cinepi-raw/#recompiling-cinepi-raw","text":"Compiling cinepi-raw For easy later rebuilding and installation of cinepi-raw you can create the file compile-raw.sh. nano compile-raw.sh Paste this into the file sudo meson install -C build Exit by pressing Ctrl+C Make it exectutable: sudo chmod +x compile-raw.sh Now, from the same folder, to build and install cinepi-raw: ./compile-raw.sh","title":"Recompiling cinepi-raw"},{"location":"config-txt/","text":"Modifying config.txt # Adjusting config.txt for different sensors: # For easy editing of config.txt on the preinstalled image file, type editboot anywhere in Raspberry Pi terminal. If using a manual install without the above alias, type: sudo nano /boot/firmware/config.txt Uncomment the section for the sensor being used, and make sure to comment out the others. Reboot the Pi for changes to take effect. Example config.txt # # For more options and information see # http://rptl.io/configtxt # Some settings may impact device functionality. See link above for details # Uncomment some or all of these to enable the optional hardware interfaces dtparam = i2c_arm = on #dtparam=i2s=on #dtparam=spi=on # Enable audio (loads snd_bcm2835) dtparam = audio = on # ---- Camera section # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283 # Starlight Eye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # Starlight Eye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # ----- # Automatically load overlays for detected DSI displays display_auto_detect = 1 # Automatically load initramfs files, if found auto_initramfs = 1 # Enable DRM VC4 V3D driver dtoverlay = vc4-kms-v3d max_framebuffers = 2 # Don't have the firmware create an initial video= setting in cmdline.txt. # Use the kernel's default instead. disable_fw_kms_setup = 1 # Run in 64-bit mode arm_64bit = 1 # Disable compensation for displays with overscan disable_overscan = 1 # Run as fast as firmware / board allows arm_boost = 1 [ cm4 ] # Enable host mode on the 2711 built-in XHCI USB controller. # This line should be removed if the legacy DWC2 controller is required # (e.g. for USB device mode) or if USB support is not required. otg_mode = 1 [ cm5 ] dtoverlay = dwc2,dr_mode = host [ all ] auto_initramfs = 1 disable_splash = 1 dtparam = i2c1 = on dtoverlay = miniuart-bt Exit the editor by pressing Ctrl+C Note that Cinemate needs you to explicitly set the camera port, match that of the physical camera port you are using. Default is cam0 . The preinstalled image file comes with OneInchEye and StarlightEye preinstalled.","title":"Modifying config.txt"},{"location":"config-txt/#modifying-configtxt","text":"","title":"Modifying config.txt"},{"location":"config-txt/#adjusting-configtxt-for-different-sensors","text":"For easy editing of config.txt on the preinstalled image file, type editboot anywhere in Raspberry Pi terminal. If using a manual install without the above alias, type: sudo nano /boot/firmware/config.txt Uncomment the section for the sensor being used, and make sure to comment out the others. Reboot the Pi for changes to take effect.","title":"Adjusting config.txt for different sensors:"},{"location":"config-txt/#example-configtxt","text":"# For more options and information see # http://rptl.io/configtxt # Some settings may impact device functionality. See link above for details # Uncomment some or all of these to enable the optional hardware interfaces dtparam = i2c_arm = on #dtparam=i2s=on #dtparam=spi=on # Enable audio (loads snd_bcm2835) dtparam = audio = on # ---- Camera section # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283 # Starlight Eye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # Starlight Eye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # ----- # Automatically load overlays for detected DSI displays display_auto_detect = 1 # Automatically load initramfs files, if found auto_initramfs = 1 # Enable DRM VC4 V3D driver dtoverlay = vc4-kms-v3d max_framebuffers = 2 # Don't have the firmware create an initial video= setting in cmdline.txt. # Use the kernel's default instead. disable_fw_kms_setup = 1 # Run in 64-bit mode arm_64bit = 1 # Disable compensation for displays with overscan disable_overscan = 1 # Run as fast as firmware / board allows arm_boost = 1 [ cm4 ] # Enable host mode on the 2711 built-in XHCI USB controller. # This line should be removed if the legacy DWC2 controller is required # (e.g. for USB device mode) or if USB support is not required. otg_mode = 1 [ cm5 ] dtoverlay = dwc2,dr_mode = host [ all ] auto_initramfs = 1 disable_splash = 1 dtparam = i2c1 = on dtoverlay = miniuart-bt Exit the editor by pressing Ctrl+C Note that Cinemate needs you to explicitly set the camera port, match that of the physical camera port you are using. Default is cam0 . The preinstalled image file comes with OneInchEye and StarlightEye preinstalled.","title":"Example config.txt"},{"location":"contributing/","text":"","title":"Contributing"},{"location":"contributors/","text":"","title":"Contributors"},{"location":"controller-methods/","text":"CinePi Controller Methods # CineMate exposes most of its runtime features through the CinePiController class in src/module/cinepi_controller.py . Buttons, the pseudo\u2011CLI and the web UI all call these methods. Below is an overview of the most useful ones and what they do. Recording # rec() \u2013 Toggle recording on or off depending on the current state. start_recording() \u2013 Begin recording if storage is mounted and space is available. stop_recording() \u2013 Stop the current recording. Exposure settings # These methods adjust ISO, shutter angle and frame rate. Increment/decrement helpers step through the arrays defined in settings.json unless free mode is active. set_iso(value) \u2013 Set ISO to a specific value. inc_iso() / dec_iso() \u2013 Step ISO up or down. set_shutter_a(value) \u2013 Set the actual shutter angle. In normal mode the value snaps to the nearest valid angle. inc_shutter_a() / dec_shutter_a() \u2013 Cycle through shutter angles. set_shutter_a_nom(value) \u2013 Set the nominal shutter angle used for motion\u2011blur calculations. inc_shutter_a_nom() / dec_shutter_a_nom() \u2013 Step the nominal shutter angle. set_fps(value) \u2013 Apply a new frame rate while respecting locks and sync mode. inc_fps() / dec_fps() \u2013 Step through the configured FPS list. White balance # set_wb(kelvin=None, direction='next') \u2013 Set white balance to a specific Kelvin temperature or cycle through presets if no value is given. inc_wb() / dec_wb() \u2013 Move to the next or previous white balance preset. Resolution and preview # set_resolution(value=None) \u2013 Switch sensor mode. Passing None cycles through the available modes. set_anamorphic_factor(value=None) \u2013 Change the preview\u2019s anamorphic stretch. Omit the value to toggle between presets. set_zoom(value=None, direction=\"next\") \u2013 Adjust the digital zoom factor. Without a value it steps through preview.zoom_steps . inc_zoom() / dec_zoom() \u2013 Convenience wrappers around set_zoom() . Storage control # mount() / unmount() \u2013 Mount or unmount the external drive. toggle_mount() \u2013 Convenience method that mounts when no drive is present and unmounts otherwise. System information # print_settings() \u2013 Log all current Redis parameters. ssd_monitor.space_left() \u2013 Report remaining disk space (used by the space CLI command). reboot() \u2013 Safely reboot the Pi. safe_shutdown() \u2013 Shut the Pi down cleanly. restart_cinemate() \u2013 Restart the Cinemate Python process without rebooting. Locks and sync modes # These helpers prevent accidental changes or keep shutter speed in sync with FPS: set_shutter_a_sync_mode(value=None) \u2013 Enable exposure\u2011sync mode (1) or normal mode (0). Omitting the value toggles the state. set_iso_lock(value=None) \u2013 Toggle or explicitly set the ISO lock. set_shutter_a_nom_lock(value=None) \u2013 Lock or unlock the nominal shutter angle. set_shu_fps_lock(value=None) \u2013 Lock both shutter angle and FPS together. set_fps_lock(value=None) \u2013 Lock or unlock the frame rate. set_all_lock(value=None) \u2013 Toggle all three locks at once. set_fps_double(value=None) \u2013 Temporarily double the frame rate. Omit the value to toggle. Free\u2011mode toggles # When free mode is enabled, the preset arrays from settings.json are ignored and you can dial any value supported by the sensor. set_iso_free(value=None) set_shutter_a_free(value=None) set_fps_free(value=None) set_wb_free(value=None) Sensor\u2011specific tools # set_filter(value=None) \u2013 Enable or disable the StarlightEye IR cut filter (IMX585 sensors only).","title":"CinePi Controller Methods"},{"location":"controller-methods/#cinepi-controller-methods","text":"CineMate exposes most of its runtime features through the CinePiController class in src/module/cinepi_controller.py . Buttons, the pseudo\u2011CLI and the web UI all call these methods. Below is an overview of the most useful ones and what they do.","title":"CinePi Controller Methods"},{"location":"controller-methods/#recording","text":"rec() \u2013 Toggle recording on or off depending on the current state. start_recording() \u2013 Begin recording if storage is mounted and space is available. stop_recording() \u2013 Stop the current recording.","title":"Recording"},{"location":"controller-methods/#exposure-settings","text":"These methods adjust ISO, shutter angle and frame rate. Increment/decrement helpers step through the arrays defined in settings.json unless free mode is active. set_iso(value) \u2013 Set ISO to a specific value. inc_iso() / dec_iso() \u2013 Step ISO up or down. set_shutter_a(value) \u2013 Set the actual shutter angle. In normal mode the value snaps to the nearest valid angle. inc_shutter_a() / dec_shutter_a() \u2013 Cycle through shutter angles. set_shutter_a_nom(value) \u2013 Set the nominal shutter angle used for motion\u2011blur calculations. inc_shutter_a_nom() / dec_shutter_a_nom() \u2013 Step the nominal shutter angle. set_fps(value) \u2013 Apply a new frame rate while respecting locks and sync mode. inc_fps() / dec_fps() \u2013 Step through the configured FPS list.","title":"Exposure settings"},{"location":"controller-methods/#white-balance","text":"set_wb(kelvin=None, direction='next') \u2013 Set white balance to a specific Kelvin temperature or cycle through presets if no value is given. inc_wb() / dec_wb() \u2013 Move to the next or previous white balance preset.","title":"White balance"},{"location":"controller-methods/#resolution-and-preview","text":"set_resolution(value=None) \u2013 Switch sensor mode. Passing None cycles through the available modes. set_anamorphic_factor(value=None) \u2013 Change the preview\u2019s anamorphic stretch. Omit the value to toggle between presets. set_zoom(value=None, direction=\"next\") \u2013 Adjust the digital zoom factor. Without a value it steps through preview.zoom_steps . inc_zoom() / dec_zoom() \u2013 Convenience wrappers around set_zoom() .","title":"Resolution and preview"},{"location":"controller-methods/#storage-control","text":"mount() / unmount() \u2013 Mount or unmount the external drive. toggle_mount() \u2013 Convenience method that mounts when no drive is present and unmounts otherwise.","title":"Storage control"},{"location":"controller-methods/#system-information","text":"print_settings() \u2013 Log all current Redis parameters. ssd_monitor.space_left() \u2013 Report remaining disk space (used by the space CLI command). reboot() \u2013 Safely reboot the Pi. safe_shutdown() \u2013 Shut the Pi down cleanly. restart_cinemate() \u2013 Restart the Cinemate Python process without rebooting.","title":"System information"},{"location":"controller-methods/#locks-and-sync-modes","text":"These helpers prevent accidental changes or keep shutter speed in sync with FPS: set_shutter_a_sync_mode(value=None) \u2013 Enable exposure\u2011sync mode (1) or normal mode (0). Omitting the value toggles the state. set_iso_lock(value=None) \u2013 Toggle or explicitly set the ISO lock. set_shutter_a_nom_lock(value=None) \u2013 Lock or unlock the nominal shutter angle. set_shu_fps_lock(value=None) \u2013 Lock both shutter angle and FPS together. set_fps_lock(value=None) \u2013 Lock or unlock the frame rate. set_all_lock(value=None) \u2013 Toggle all three locks at once. set_fps_double(value=None) \u2013 Temporarily double the frame rate. Omit the value to toggle.","title":"Locks and sync modes"},{"location":"controller-methods/#freemode-toggles","text":"When free mode is enabled, the preset arrays from settings.json are ignored and you can dial any value supported by the sensor. set_iso_free(value=None) set_shutter_a_free(value=None) set_fps_free(value=None) set_wb_free(value=None)","title":"Free\u2011mode toggles"},{"location":"controller-methods/#sensorspecific-tools","text":"set_filter(value=None) \u2013 Enable or disable the StarlightEye IR cut filter (IMX585 sensors only).","title":"Sensor\u2011specific tools"},{"location":"coverpage/","text":"Built: 2026-01-26 21:18 UTC","title":"Cinemate Documentation"},{"location":"digital-zoom/","text":"","title":"Digital zoom"},{"location":"dual-sensors/","text":"Dual sensors # CineMate automatically detects each camera connected to the Raspberry Pi and spawns a separate cinepi-raw process per sensor. By default: Primary camera (first detected) displays its preview on HDMI port 0. Secondary cameras run with --nopreview and map to subsequent HDMI outputs (cam1\u2192HDMI 1, cam2\u2192HDMI 2, etc.). Preview windows are centered and sized according to your geometry settings. Cameras are synchronized with cam0 being the server and cam1 being the client. On Raspberry Pi 5 Compute Model carrier boards, the second CSI connector (cam1) may appear as i2c@70000 in --list-cameras . Cinemate maps this path to cam1 so each sensor gets the correct port assignment. When using the cam1 with the official Raspberry Pi CM carrier board, make sure to connect the JC GPIO pins as described here: https://www.raspberrypi.com/documentation/computers/compute-module.html#connect-two-cameras You can override default HDMI mappings in settings.json under the output section.","title":"Dual sensors"},{"location":"dual-sensors/#dual-sensors","text":"CineMate automatically detects each camera connected to the Raspberry Pi and spawns a separate cinepi-raw process per sensor. By default: Primary camera (first detected) displays its preview on HDMI port 0. Secondary cameras run with --nopreview and map to subsequent HDMI outputs (cam1\u2192HDMI 1, cam2\u2192HDMI 2, etc.). Preview windows are centered and sized according to your geometry settings. Cameras are synchronized with cam0 being the server and cam1 being the client. On Raspberry Pi 5 Compute Model carrier boards, the second CSI connector (cam1) may appear as i2c@70000 in --list-cameras . Cinemate maps this path to cam1 so each sensor gets the correct port assignment. When using the cam1 with the official Raspberry Pi CM carrier board, make sure to connect the JC GPIO pins as described here: https://www.raspberrypi.com/documentation/computers/compute-module.html#connect-two-cameras You can override default HDMI mappings in settings.json under the output section.","title":"Dual sensors"},{"location":"fps-correction/","text":"FPS correction factors and audio sync # Some sensors report different effective frame rates than the requested FPS. This is typically caused by sensor timing details such as vertical blanking (vblank). Vblank changes the total line time the sensor needs per frame, which in turn shifts the true FPS even when the target FPS stays constant. Cinemate compensates for this by applying an FPS correction factor so the captured frame timing lines up with your intended rate. With the properly fine-tuned correction factor we can achieve pretty good sync to both onboard and external audio recording Why the correction factor is per sensor, mode, and FPS # Each sensor model exposes its own timing characteristics. On top of that, every sensor mode (resolution/bit depth) has different blanking and pixel-clock constraints. The requested FPS also changes how the sensor clocks out frames. Because of these combined dependencies, Cinemate stores a correction factor for every sensor type + resolution/mode + FPS triplet in the file src/module/sensor_correction_factors.py . Running a fixed\u2011frame calibration clip # To validate or tune the correction factor, you can record a clip with a fixed frame count: rec f 1000 This records exactly 1000 frames (based on the current FPS) and stops automatically. Cinemate knows exactly how many frames should have landed over the elapsed duration and when recording stops it performs an analysis and proposes an fps correction factor How Cinemate analyzes the results # After the recording finishes, Cinemate compares the expected frame count with the actual frames captured. When there is a mismatch, it derives a suggested correction factor and suggests it to the user. If the frame count lands on the expected number of frames (with the tolerance of +/- 1 frame), it suggests to keep the existing correction factor. See here how to run Cinemate manually.","title":"FPS correction and audio sync"},{"location":"fps-correction/#fps-correction-factors-and-audio-sync","text":"Some sensors report different effective frame rates than the requested FPS. This is typically caused by sensor timing details such as vertical blanking (vblank). Vblank changes the total line time the sensor needs per frame, which in turn shifts the true FPS even when the target FPS stays constant. Cinemate compensates for this by applying an FPS correction factor so the captured frame timing lines up with your intended rate. With the properly fine-tuned correction factor we can achieve pretty good sync to both onboard and external audio recording","title":"FPS correction factors and audio sync"},{"location":"fps-correction/#why-the-correction-factor-is-per-sensor-mode-and-fps","text":"Each sensor model exposes its own timing characteristics. On top of that, every sensor mode (resolution/bit depth) has different blanking and pixel-clock constraints. The requested FPS also changes how the sensor clocks out frames. Because of these combined dependencies, Cinemate stores a correction factor for every sensor type + resolution/mode + FPS triplet in the file src/module/sensor_correction_factors.py .","title":"Why the correction factor is per sensor, mode, and FPS"},{"location":"fps-correction/#running-a-fixedframe-calibration-clip","text":"To validate or tune the correction factor, you can record a clip with a fixed frame count: rec f 1000 This records exactly 1000 frames (based on the current FPS) and stops automatically. Cinemate knows exactly how many frames should have landed over the elapsed duration and when recording stops it performs an analysis and proposes an fps correction factor","title":"Running a fixed\u2011frame calibration clip"},{"location":"fps-correction/#how-cinemate-analyzes-the-results","text":"After the recording finishes, Cinemate compares the expected frame count with the actual frames captured. When there is a mismatch, it derives a suggested correction factor and suggests it to the user. If the frame count lands on the expected number of frames (with the tolerance of +/- 1 frame), it suggests to keep the existing correction factor. See here how to run Cinemate manually.","title":"How Cinemate analyzes the results"},{"location":"getting-started/","text":"Quick start # Hardware requirements # Raspberry Pi 5 or 4 Official HQ or Global Shutter camera HDMI monitor or a phone/tablet for monitoring For most users the 4GB or even 2GB models are sufficient. More RAM gives you a larger frame buffer. But ideally you don\u2019t want to have to use the framebuffer anyway, as realtime writing to storage is preferred. There could be some rare high speed slomo cases you would want faster frame capture for short bursts but in most cases, the 4GB models will do fine. Installation # Burn the latest Cinemate image to an SD card (8 GB or larger). Connect the Pi and the camera sensor board, connect power an boot the Pi. Cinemate should autstart on boot. Ensure the Pi is powered off before attaching the camera ribbon cable. Hot-swapping may damage the hardware. Preview # Plug in an HDMI monitor or Connect your phone/tablet to the Wi\u2011Fi network CinePi (password 11111111 ). Open a browser and go to cinepi.local:5000 to see the interface. A clean video feed without the GUI is available at cinepi.local:8000/stream . Recording # Attach a high\u2011speed drive: an SSD (Samsung T7 recommended), an NVMe drive , or the CFE Hat . Make sure storage media is formatted as ext4 and labeled RAW . Connect a button between GPIO5 and GND (or briefly short these pins with a paper clip). When using the phone preview, you can also start/stop recording by tapping the preview. That's it\u2014your bare\u2011bones Cinemate build is ready! Remember to power everything down before disconnecting hardware!","title":"Getting started with a minimal build"},{"location":"getting-started/#quick-start","text":"","title":"Quick start"},{"location":"getting-started/#hardware-requirements","text":"Raspberry Pi 5 or 4 Official HQ or Global Shutter camera HDMI monitor or a phone/tablet for monitoring For most users the 4GB or even 2GB models are sufficient. More RAM gives you a larger frame buffer. But ideally you don\u2019t want to have to use the framebuffer anyway, as realtime writing to storage is preferred. There could be some rare high speed slomo cases you would want faster frame capture for short bursts but in most cases, the 4GB models will do fine.","title":"Hardware requirements"},{"location":"getting-started/#installation","text":"Burn the latest Cinemate image to an SD card (8 GB or larger). Connect the Pi and the camera sensor board, connect power an boot the Pi. Cinemate should autstart on boot. Ensure the Pi is powered off before attaching the camera ribbon cable. Hot-swapping may damage the hardware.","title":"Installation"},{"location":"getting-started/#preview","text":"Plug in an HDMI monitor or Connect your phone/tablet to the Wi\u2011Fi network CinePi (password 11111111 ). Open a browser and go to cinepi.local:5000 to see the interface. A clean video feed without the GUI is available at cinepi.local:8000/stream .","title":"Preview"},{"location":"getting-started/#recording","text":"Attach a high\u2011speed drive: an SSD (Samsung T7 recommended), an NVMe drive , or the CFE Hat . Make sure storage media is formatted as ext4 and labeled RAW . Connect a button between GPIO5 and GND (or briefly short these pins with a paper clip). When using the phone preview, you can also start/stop recording by tapping the preview. That's it\u2014your bare\u2011bones Cinemate build is ready! Remember to power everything down before disconnecting hardware!","title":"Recording"},{"location":"hardware-controls/","text":"","title":"Hardware controls"},{"location":"hardware-introduction/","text":"","title":"Hardware introduction"},{"location":"hotspot-logic/","text":"Configuring the Wi-Fi hotspot # The built\u2011in hotspot ensures you can always reach Cinemate even when there is no other network available. When wifi_hotspot in settings.json is set to true and no hotspot is active, Cinemate runs nmcli device wifi hotspot using your chosen SSID and password. This is handy when shooting in the field. Connect your phone or laptop directly to the hotspot and browse to the GUI to control the camera. If the Pi was previously connected to a Wi\u2011Fi network, that connection is replaced by the hotspot. During development you may want the Pi to join your normal Wi\u2011Fi so it has internet access. Set system.wifi_hotspot.enabled to false and configure Wi\u2011Fi through raspi-config or the desktop tools. The web interface will appear on the Pi's regular network address, letting you stay connected to both the Pi and the internet. If you plug an Ethernet cable into the Pi, you can keep the hotspot running while also having a wired connection for internet and local networking. Note that Cinemate still streams its web gui on whatever network the Pi is connected to, with GUI at <ip-address>:5000 and clean preview on <ip-address>:8000/stream .","title":"Configuring the Wi-Fi hotspot"},{"location":"hotspot-logic/#configuring-the-wi-fi-hotspot","text":"The built\u2011in hotspot ensures you can always reach Cinemate even when there is no other network available. When wifi_hotspot in settings.json is set to true and no hotspot is active, Cinemate runs nmcli device wifi hotspot using your chosen SSID and password. This is handy when shooting in the field. Connect your phone or laptop directly to the hotspot and browse to the GUI to control the camera. If the Pi was previously connected to a Wi\u2011Fi network, that connection is replaced by the hotspot. During development you may want the Pi to join your normal Wi\u2011Fi so it has internet access. Set system.wifi_hotspot.enabled to false and configure Wi\u2011Fi through raspi-config or the desktop tools. The web interface will appear on the Pi's regular network address, letting you stay connected to both the Pi and the internet. If you plug an Ethernet cable into the Pi, you can keep the hotspot running while also having a wired connection for internet and local networking. Note that Cinemate still streams its web gui on whatever network the Pi is connected to, with GUI at <ip-address>:5000 and clean preview on <ip-address>:8000/stream .","title":"Configuring the Wi-Fi hotspot"},{"location":"image-circle/","text":"","title":"Image circle"},{"location":"installation-steps%20copy%202/","text":"Installation # Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Although Raspberry Pi 4 (and even 3) has been known to work with the stack below, a Raspopberry Pi 5B or Compute Module 5 is recommended. Also note that for high speed USB 3, a Raspberry Pi 4 or 5 is needed. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.34 (this is what you get with the official Raspberry Pi imager and doing a sudo apt update && sudo apt upgrade). If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt-get install python3-jinja2 python3-ply python3-yaml Manual install # Tools & dependencies # sudo apt update && sudo apt upgrade sudo apt install - y cmake libepoxy - dev libavdevice - dev build - essential cmake libboost - program - options - dev libdrm - dev libexif - dev libcamera - dev libjpeg - dev libtiff5 - dev libpng - dev redis - server libhiredis - dev libasound2 - dev libjsoncpp - dev libpng - dev meson ninja - build libavcodec - dev libavdevice - dev libavformat - dev libswresample - dev && sudo apt - get install libjsoncpp - dev && cd ~ && git clone https : //github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~ libcamera 1.7.0 # sudo apt install -y python3-pip git python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install cpp-mjpeg-streamer # sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd CinePi-raw # git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF imx585 driver # sudo apt install linux-headers dkms git git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye Add the IMX585 tuning files (optional) # curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl - L - o / home / pi / libcamera / src / ipa / rpi / pisp / data / imx585_mono . json https : //raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/ IR filter switch script (optional) # sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate imx283 driver # sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh The imx283 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/imx283-v4l2-driver Enabling I\u00b2C # sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules. Setting hostname # sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates Add camera modules to config.txt # sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to. # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1 Change the console font (optional) # sudo apt update sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose Terminus / 16x32 Verify /etc/default/console-setup contains: FONTFACE=\"Terminus\" FONTSIZE=\"16x32\" Then enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor Create post-processing configs # Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json Install PiShrink # wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions Reboot: # sudo reboot Trying out CinePi from the terminal # You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section . Cinemate # Create a Python virtual environment # sudo apt update && sudo apt install -y python3-venv python3 -m venv /home/pi/.cinemate-env echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc source /home/pi/.cinemate-env/bin/activate Grant sudo privileges and enable I\u00b2C # echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: reboot Dependencies # python3 -m pip install --upgrade pip setuptools wheel sudo apt-get install -y i2c-tools portaudio19-dev build-essential python3-dev python3-pip python3-smbus python3-serial git pip3 install adafruit-circuitpython-ssd1306 watchdog psutil Pillow redis keyboard pyudev sounddevice smbus2 gpiozero RPI.GPIO evdev termcolor pyserial inotify_simple numpy rpi_hardware_pwm pip3 uninstall -y Pillow && pip3 install Pillow pip3 install sugarpie flask_socketio adafruit-blinka adafruit-circuitpython-seesaw luma.oled grove.py pigpio-encoder gpiod sudo apt install python3-systemd e2fsprogs ntfs-3g exfatprogs console-terminus If you previously installed the board Python package, remove it with pip3 uninstall board . Replace RPi.GPIO with lgpio # sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio Clone the Cinemate repo # git clone https://github.com/Tiramisioux/cinemate.git Allow Cinemate to run with sudo # Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x Enable NetworkManager # sudo systemctl enable NetworkManager --now Rotate logs # Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP Seed Redis with default keys # redis-cli <<'EOF' SET anamorphic_factor 1.0 PUBLISH cp_controls anamorphic_factor SET bit_depth 12 PUBLISH cp_controls bit_depth EOF (See the settings guide for the full list.) Add a convenience alias # nano ~/.bashrc add to the end of the file # alias cinemate = 'python3 /home/pi/cinemate/src/main.py' Exit with Ctrl+x Reload .bashrc source ~/.bashrc Cinemate services # Cinemate with two small helper services under services/ : storage-automount # Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. Partitions named RAW are attached at /media/RAW ; all others are mounted under /media/<LABEL> . wifi-hotspot # keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI even without other networking. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make enable Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] ... Connect to the Pi: ssh pi @10.42.0.1 # password: 1 Starting Cinemate # Initializing Redis Keys # This has only to be done once on your system: redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 2 .5,2.2 \\ file_size 0 fps 1 fps_actual 1 fps_last 1 fps_max 1 fps_user 1 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 0 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ trigger_mode 0 wb 0 wb_user 0 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service: cinemate-autostart.service # cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. Tip: sudo make install also places /usr/local/bin/camera-ready.sh on the system. The script waits for cinepi-raw to report a camera before systemd launches Cinemate, preventing the black-screen-on-boot issue that occurred when the GUI started before the sensor initialised. Thinking about the wifi-hotspot service The optional wifi-hotspot service gives the Pi its own wireless network so you can always connect to the web interface. It is great for field work where there may be no existing network. Simply join the CinePi network on your phone or laptop and browse to the GUI. During development you might prefer the Pi to use your normal Wi\u2011Fi instead so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false in settings.json or by stopping the service with sudo systemctl stop wifi-hotspot . If you plug in an Ethernet cable you can keep the hotspot active while the wired connection provides internet access. See Hotspot logic for more details on how the hotspot works.","title":"Installation"},{"location":"installation-steps%20copy%202/#installation","text":"Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Although Raspberry Pi 4 (and even 3) has been known to work with the stack below, a Raspopberry Pi 5B or Compute Module 5 is recommended. Also note that for high speed USB 3, a Raspberry Pi 4 or 5 is needed. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.34 (this is what you get with the official Raspberry Pi imager and doing a sudo apt update && sudo apt upgrade). If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt-get install python3-jinja2 python3-ply python3-yaml","title":"Installation"},{"location":"installation-steps%20copy%202/#manual-install","text":"","title":"Manual install"},{"location":"installation-steps%20copy%202/#tools-dependencies","text":"sudo apt update && sudo apt upgrade sudo apt install - y cmake libepoxy - dev libavdevice - dev build - essential cmake libboost - program - options - dev libdrm - dev libexif - dev libcamera - dev libjpeg - dev libtiff5 - dev libpng - dev redis - server libhiredis - dev libasound2 - dev libjsoncpp - dev libpng - dev meson ninja - build libavcodec - dev libavdevice - dev libavformat - dev libswresample - dev && sudo apt - get install libjsoncpp - dev && cd ~ && git clone https : //github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~","title":"Tools &amp; dependencies"},{"location":"installation-steps%20copy%202/#libcamera-170","text":"sudo apt install -y python3-pip git python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install","title":"libcamera 1.7.0"},{"location":"installation-steps%20copy%202/#cpp-mjpeg-streamer","text":"sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd","title":"cpp-mjpeg-streamer"},{"location":"installation-steps%20copy%202/#cinepi-raw","text":"git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF","title":"CinePi-raw"},{"location":"installation-steps%20copy%202/#imx585-driver","text":"sudo apt install linux-headers dkms git git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye","title":"imx585 driver"},{"location":"installation-steps%20copy%202/#add-the-imx585-tuning-files-optional","text":"curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl - L - o / home / pi / libcamera / src / ipa / rpi / pisp / data / imx585_mono . json https : //raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/","title":"Add the IMX585 tuning files (optional)"},{"location":"installation-steps%20copy%202/#ir-filter-switch-script-optional","text":"sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate","title":"IR filter switch script (optional)"},{"location":"installation-steps%20copy%202/#imx283-driver","text":"sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh The imx283 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/imx283-v4l2-driver","title":"imx283 driver"},{"location":"installation-steps%20copy%202/#enabling-i2c","text":"sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules.","title":"Enabling I\u00b2C"},{"location":"installation-steps%20copy%202/#setting-hostname","text":"sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates","title":"Setting hostname"},{"location":"installation-steps%20copy%202/#add-camera-modules-to-configtxt","text":"sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to. # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1","title":"Add camera modules to config.txt"},{"location":"installation-steps%20copy%202/#change-the-console-font-optional","text":"sudo apt update sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose Terminus / 16x32 Verify /etc/default/console-setup contains: FONTFACE=\"Terminus\" FONTSIZE=\"16x32\" Then enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor","title":"Change the console font (optional)"},{"location":"installation-steps%20copy%202/#create-post-processing-configs","text":"Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json","title":"Create post-processing configs"},{"location":"installation-steps%20copy%202/#install-pishrink","text":"wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions","title":"Install PiShrink"},{"location":"installation-steps%20copy%202/#reboot","text":"sudo reboot","title":"Reboot:"},{"location":"installation-steps%20copy%202/#trying-out-cinepi-from-the-terminal","text":"You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section .","title":"Trying out CinePi from the terminal"},{"location":"installation-steps%20copy%202/#cinemate","text":"","title":"Cinemate"},{"location":"installation-steps%20copy%202/#create-a-python-virtual-environment","text":"sudo apt update && sudo apt install -y python3-venv python3 -m venv /home/pi/.cinemate-env echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc source /home/pi/.cinemate-env/bin/activate","title":"Create a Python virtual environment"},{"location":"installation-steps%20copy%202/#grant-sudo-privileges-and-enable-i2c","text":"echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: reboot","title":"Grant sudo privileges and enable I\u00b2C"},{"location":"installation-steps%20copy%202/#dependencies","text":"python3 -m pip install --upgrade pip setuptools wheel sudo apt-get install -y i2c-tools portaudio19-dev build-essential python3-dev python3-pip python3-smbus python3-serial git pip3 install adafruit-circuitpython-ssd1306 watchdog psutil Pillow redis keyboard pyudev sounddevice smbus2 gpiozero RPI.GPIO evdev termcolor pyserial inotify_simple numpy rpi_hardware_pwm pip3 uninstall -y Pillow && pip3 install Pillow pip3 install sugarpie flask_socketio adafruit-blinka adafruit-circuitpython-seesaw luma.oled grove.py pigpio-encoder gpiod sudo apt install python3-systemd e2fsprogs ntfs-3g exfatprogs console-terminus If you previously installed the board Python package, remove it with pip3 uninstall board .","title":"Dependencies"},{"location":"installation-steps%20copy%202/#replace-rpigpio-with-lgpio","text":"sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio","title":"Replace RPi.GPIO with lgpio"},{"location":"installation-steps%20copy%202/#clone-the-cinemate-repo","text":"git clone https://github.com/Tiramisioux/cinemate.git","title":"Clone the Cinemate repo"},{"location":"installation-steps%20copy%202/#allow-cinemate-to-run-with-sudo","text":"Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x","title":"Allow Cinemate to run with sudo"},{"location":"installation-steps%20copy%202/#enable-networkmanager","text":"sudo systemctl enable NetworkManager --now","title":"Enable NetworkManager"},{"location":"installation-steps%20copy%202/#rotate-logs","text":"Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP","title":"Rotate logs"},{"location":"installation-steps%20copy%202/#seed-redis-with-default-keys","text":"redis-cli <<'EOF' SET anamorphic_factor 1.0 PUBLISH cp_controls anamorphic_factor SET bit_depth 12 PUBLISH cp_controls bit_depth EOF (See the settings guide for the full list.)","title":"Seed Redis with default keys"},{"location":"installation-steps%20copy%202/#add-a-convenience-alias","text":"nano ~/.bashrc","title":"Add a convenience alias"},{"location":"installation-steps%20copy%202/#add-to-the-end-of-the-file","text":"alias cinemate = 'python3 /home/pi/cinemate/src/main.py' Exit with Ctrl+x Reload .bashrc source ~/.bashrc","title":"add to the end of the file"},{"location":"installation-steps%20copy%202/#cinemate-services","text":"Cinemate with two small helper services under services/ :","title":"Cinemate services"},{"location":"installation-steps%20copy%202/#storage-automount","text":"Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. Partitions named RAW are attached at /media/RAW ; all others are mounted under /media/<LABEL> .","title":"storage-automount"},{"location":"installation-steps%20copy%202/#wifi-hotspot","text":"keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI even without other networking. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make enable Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] ... Connect to the Pi: ssh pi @10.42.0.1 # password: 1","title":"wifi-hotspot"},{"location":"installation-steps%20copy%202/#starting-cinemate","text":"","title":"Starting Cinemate"},{"location":"installation-steps%20copy%202/#initializing-redis-keys","text":"This has only to be done once on your system: redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 2 .5,2.2 \\ file_size 0 fps 1 fps_actual 1 fps_last 1 fps_max 1 fps_user 1 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 0 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ trigger_mode 0 wb 0 wb_user 0 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service:","title":"Initializing Redis Keys"},{"location":"installation-steps%20copy%202/#cinemate-autostartservice","text":"cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. Tip: sudo make install also places /usr/local/bin/camera-ready.sh on the system. The script waits for cinepi-raw to report a camera before systemd launches Cinemate, preventing the black-screen-on-boot issue that occurred when the GUI started before the sensor initialised. Thinking about the wifi-hotspot service The optional wifi-hotspot service gives the Pi its own wireless network so you can always connect to the web interface. It is great for field work where there may be no existing network. Simply join the CinePi network on your phone or laptop and browse to the GUI. During development you might prefer the Pi to use your normal Wi\u2011Fi instead so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false in settings.json or by stopping the service with sudo systemctl stop wifi-hotspot . If you plug in an Ethernet cable you can keep the hotspot active while the wired connection provides internet access. See Hotspot logic for more details on how the hotspot works.","title":"cinemate-autostart.service"},{"location":"installation-steps%20copy/","text":"%%{init: {\"theme\":\"base\", \"themeVariables\" :{ \"primaryColor\" : \"#2980b9\" , \"secondaryColor\" : \"#e7f2fa\" , \"tertiaryColor\" : \"#f5f5f5\" , \"fontFamily\" : \"Roboto, Arial, sans-serif\" }} } %% graph TD Sensor [ \"Camera Sensor\" ]::: component Pi [ \"Raspberry Pi SoC\" ]::: component Libcamera [ \"libcamera (1.7.0)\" ]::: component CinePi [ \"cinepi-raw (C++)\" ]::: component RedisKV [ \"Redis Key\u2011Value Store\" ]::: redis Cinemate [ \"Cinemate (Python UI)\" ]::: ui Sensor --> Pi Pi --> Libcamera Libcamera --> CinePi RedisKV --> CinePi Cinemate <--> RedisKV classDef component fill : # ffffff , stroke : #2980 b9 , color : #2980 b9 ; classDef redis fill:#ffd43b,stroke:#2980b9,color:#000 ; classDef ui fill:#c6e48b,stroke:#2980b9,color:#000 ; Formatting can also be applied to blocks by putting the opening and closing tags on separate lines and adding new lines between the tags and the content. Let's give readers a helpful hint! ::: This is my note graph TD DSLR [ \"Camera Body\" ] -->| HDMI | Pi [ Pi 4 B ] Pi -->| USB | SSD %%{ init: { \"theme\" : \"base\" , /* \u2190 only \u201c base \u201d can be customised */ \"themeVariables\" : { \"background\" : \"#603e3eff\" /* \u2460 canvas colour */ } } } %% graph TD %% \u2461 either give each node a one-off style\u2026 Sensor [ \"Camera Sensor\" ] style Sensor fill : # fff8e1 , stroke : # c9a60a , stroke - width : 2 px , color : # 333 Pi [ \"Raspberry Pi SoC\" ] style Pi fill : # e1f5fe , stroke : #0288 d1 , stroke - width : 2 px Libcamera [ \"libcamera (1.7.0)\" ] style Libcamera fill : # ede7f6 , stroke : #673 ab7 , stroke - width : 2 px %% \u2026or assign them to a reusable class CinePi [ \"CinePi-RAW (C++)\" ]::: code RedisKV [ \"Redis Key-Value Store\" ]::: code Cinemate [ \"Cinemate (Python UI)\" ]::: code classDef code fill : # e8f5e9 , stroke : #2 e7d32 , stroke - width : 2 px , color : # 000 ; Sensor --> Pi Pi --> Libcamera Libcamera --> CinePi CinePi <--> RedisKV Cinemate <--> RedisKV def bubble_sort ( items ) : for i in range ( len ( items )) : for j in range ( len ( items ) - 1 - i ) : if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] #!math p(x|y) = \\frac{p(y|x)p(x)}{p(y)} :::python # Code goes here ... :::python hl_lines=\"1 3\" # This line is emphasized # This line isn't # This line is emphasized print ( 'hellow world' ) Text can be deleted and replacement text added . This can also be combined into one a single operation. Highlighting is also possible and comments can be added inline . hellow world')","title":"Installation steps copy"},{"location":"installation-steps/","text":"Installation # Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Stack works on Raspberry Pi 4 and 5 models. 2 GB RAM is sufficient, while more RAM will give you a larger framebuffer. Useful at high frame rates. Cinemate is using Linux kernel version 6.12.25. Recommended OS is Bookworm Lite. Tools & dependencies # sudo apt update -y sudo apt upgrade -y sudo apt-get install python3-jinja2 python3-ply python3-yaml sudo apt install - y git cmake libepoxy - dev libavdevice - dev build - essential cmake libboost - program - options - dev libdrm - dev libexif - dev libcamera - dev libjpeg - dev libtiff5 - dev libpng - dev redis - server libhiredis - dev libasound2 - dev libjsoncpp - dev libpng - dev meson ninja - build libavcodec - dev libavdevice - dev libavformat - dev libswresample - dev && sudo apt - get install libjsoncpp - dev && cd ~ && git clone https : //github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~ libcamera 1.7.0 # sudo apt install -y python3-pip python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install cpp-mjpeg-streamer # sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd CinePi-RAW # git clone https://github.com/Tiramisioux/cinepi-raw.git cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd sudo ldconfig Seed Redis with white balance default keys # redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF .asoundrc Setup # For dsnoop support, create a ~/etc/asound.conf : sudo tee /etc/asound.conf >/dev/null <<'EOF' # --- Hardware handle (use stable card name; change \"NTG\" if your card shows a different name in `arecord -l`) pcm.mic_hw { type hw card \"NTG\" device 0 } # --- One shared dsnoop backend pinned to the mic's native mode (R\u00d8DE NTG: S24_3LE @ 48k, stereo) pcm.mic_dsnoop { type dsnoop ipc_key 5978 ipc_perm 0666 ipc_key_add_uid false slave { pcm \"hw:CARD=NTG,DEV=0\" format S24_3LE rate 48000 channels 2 } bindings.0 0 bindings.1 1 } # --- Front-ends: let plug adapt whatever the app asks for (stereo 24-bit or mono 16-bit) pcm.mic_24bit { type plug slave.pcm \"mic_dsnoop\" } pcm.mic_16bit { type plug slave.pcm \"mic_dsnoop\" } EOF Exit nano editor using ctrl+x. IMX585 driver (optional) # sudo apt install linux-headers dkms -y git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh cd The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye Add IMX585 tuning files # curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl - L - o / home / pi / libcamera / src / ipa / rpi / pisp / data / imx585_mono . json https : //raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/ IR filter switch script # sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate Enabling I\u00b2C # sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules. Setting hostname # sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates Add camera modules to config.txt # sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to (example shows imx477 activated) # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Change the console font (optional) # sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose: UTF-8 # Guess optimal character set # Terminus # 16x32 (framebuffer only) Enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor Create post-processing configs # Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json Install PiShrink # sudo wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh -O /usr/local/bin/pishrink.sh sudo chmod +x /usr/local/bin/pishrink.sh PiShrink is a handy tool for compressing SD image file backups of the SD card. See here for instructions Reboot # sudo reboot Trying out CinePi from the terminal # You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section . Cinemate # System wide packages # sudo apt update sudo apt install -y \\ git build-essential python3-dev python3-pip python3-venv \\ i2c-tools python3-smbus python3-pyudev \\ libgpiod-dev libgpiod2 python3-libgpiod gpiod \\ portaudio19-dev python3-systemd \\ e2fsprogs ntfs-3g exfatprogs \\ console-terminus Create a Python virtual environment # python3 -m venv ~/.cinemate-env source /home/pi/.cinemate-env/bin/activate echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc Grant sudo privileges and enable I\u00b2C # echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: sudo reboot Python packages # If you previously installed the board Python package, remove it with pip3 uninstall board . pip install \\ gpiozero \\ adafruit-blinka adafruit-circuitpython-ssd1306 adafruit-circuitpython-seesaw \\ luma.oled grove.py pigpio-encoder smbus2 rpi_hardware_pwm \\ watchdog psutil pillow redis keyboard pyudev numpy termcolor sounddevice \\ evdev inotify_simple sysv_ipc flask_socketio sugarpie Alternative GPIO back-end # sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio Clone the Cinemate repo # git clone https://github.com/Tiramisioux/cinemate.git Allow Cinemate to run with sudo # Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Enable NetworkManager # sudo systemctl enable NetworkManager --now Rotate logs # Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP Seed Redis with default keys # redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 3 .5,1.5 \\ file_size 0 fps 24 fps_actual 24 fps_last 24 fps_max 1 fps_user 24 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 100 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ wb 5600 wb_user 5600 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 (See the settings guide for the full list.) Add aliases # nano ~/.bashrc Add to the end of the file: alias cinemate = 'python3 /home/pi/cinemate/src/main.py' alias editboot = 'sudo nano /boot/firmware/config.txt' alias editsettings = 'sudo nano /home/pi/cinemate/src/settings.json' Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Reload .bashrc source ~/.bashrc Cinemate services # storage-automount # Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. wifi-hotspot # Keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI while in the field. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make start # starts the service sudo make enable # makes the service start on boot You can also start and enable the service individually, by entering their respective folders and issuing the sudo make command Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] During development/building your rig you might prefer the Pi to use your normal Wi\u2011Fi instead of its own hotspot so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false in settings.json and by stopping the service with: sudo systemctl stop wifi-hotspot To stop the hotspot from starting on boot, type sudo systemctl disable wifi-hotspot See Hotspot logic for more details on how the hotspot works. Connect to the Pi (if not already connected): # ssh pi@10.42.0.1 password: 1 Starting Cinemate # Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service: cinemate-autostart.service # cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. Tip: sudo make install also places /usr/local/bin/camera-ready.sh on the system. The script waits for cinepi-raw to report a camera before systemd launches Cinemate, preventing the black-screen-on-boot issue that occurred when the GUI started before the sensor initialised. You now have a 12 bit RAW image capturing system on your Raspberry Pi!","title":"Manual installation"},{"location":"installation-steps/#installation","text":"Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Stack works on Raspberry Pi 4 and 5 models. 2 GB RAM is sufficient, while more RAM will give you a larger framebuffer. Useful at high frame rates. Cinemate is using Linux kernel version 6.12.25. Recommended OS is Bookworm Lite.","title":"Installation"},{"location":"installation-steps/#tools-dependencies","text":"sudo apt update -y sudo apt upgrade -y sudo apt-get install python3-jinja2 python3-ply python3-yaml sudo apt install - y git cmake libepoxy - dev libavdevice - dev build - essential cmake libboost - program - options - dev libdrm - dev libexif - dev libcamera - dev libjpeg - dev libtiff5 - dev libpng - dev redis - server libhiredis - dev libasound2 - dev libjsoncpp - dev libpng - dev meson ninja - build libavcodec - dev libavdevice - dev libavformat - dev libswresample - dev && sudo apt - get install libjsoncpp - dev && cd ~ && git clone https : //github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~","title":"Tools &amp; dependencies"},{"location":"installation-steps/#libcamera-170","text":"sudo apt install -y python3-pip python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install","title":"libcamera 1.7.0"},{"location":"installation-steps/#cpp-mjpeg-streamer","text":"sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd","title":"cpp-mjpeg-streamer"},{"location":"installation-steps/#cinepi-raw","text":"git clone https://github.com/Tiramisioux/cinepi-raw.git cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd sudo ldconfig","title":"CinePi-RAW"},{"location":"installation-steps/#seed-redis-with-white-balance-default-keys","text":"redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF","title":"Seed Redis with white balance default keys"},{"location":"installation-steps/#asoundrc-setup","text":"For dsnoop support, create a ~/etc/asound.conf : sudo tee /etc/asound.conf >/dev/null <<'EOF' # --- Hardware handle (use stable card name; change \"NTG\" if your card shows a different name in `arecord -l`) pcm.mic_hw { type hw card \"NTG\" device 0 } # --- One shared dsnoop backend pinned to the mic's native mode (R\u00d8DE NTG: S24_3LE @ 48k, stereo) pcm.mic_dsnoop { type dsnoop ipc_key 5978 ipc_perm 0666 ipc_key_add_uid false slave { pcm \"hw:CARD=NTG,DEV=0\" format S24_3LE rate 48000 channels 2 } bindings.0 0 bindings.1 1 } # --- Front-ends: let plug adapt whatever the app asks for (stereo 24-bit or mono 16-bit) pcm.mic_24bit { type plug slave.pcm \"mic_dsnoop\" } pcm.mic_16bit { type plug slave.pcm \"mic_dsnoop\" } EOF Exit nano editor using ctrl+x.","title":".asoundrc Setup"},{"location":"installation-steps/#imx585-driver-optional","text":"sudo apt install linux-headers dkms -y git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh cd The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye","title":"IMX585 driver (optional)"},{"location":"installation-steps/#add-imx585-tuning-files","text":"curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl - L - o / home / pi / libcamera / src / ipa / rpi / pisp / data / imx585_mono . json https : //raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/","title":"Add IMX585 tuning files"},{"location":"installation-steps/#ir-filter-switch-script","text":"sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate","title":"IR filter switch script"},{"location":"installation-steps/#enabling-i2c","text":"sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules.","title":"Enabling I\u00b2C"},{"location":"installation-steps/#setting-hostname","text":"sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates","title":"Setting hostname"},{"location":"installation-steps/#add-camera-modules-to-configtxt","text":"sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to (example shows imx477 activated) # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter.","title":"Add camera modules to config.txt"},{"location":"installation-steps/#change-the-console-font-optional","text":"sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose: UTF-8 # Guess optimal character set # Terminus # 16x32 (framebuffer only) Enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor","title":"Change the console font (optional)"},{"location":"installation-steps/#create-post-processing-configs","text":"Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json","title":"Create post-processing configs"},{"location":"installation-steps/#install-pishrink","text":"sudo wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh -O /usr/local/bin/pishrink.sh sudo chmod +x /usr/local/bin/pishrink.sh PiShrink is a handy tool for compressing SD image file backups of the SD card. See here for instructions","title":"Install PiShrink"},{"location":"installation-steps/#reboot","text":"sudo reboot","title":"Reboot"},{"location":"installation-steps/#trying-out-cinepi-from-the-terminal","text":"You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section .","title":"Trying out CinePi from the terminal"},{"location":"installation-steps/#cinemate","text":"","title":"Cinemate"},{"location":"installation-steps/#system-wide-packages","text":"sudo apt update sudo apt install -y \\ git build-essential python3-dev python3-pip python3-venv \\ i2c-tools python3-smbus python3-pyudev \\ libgpiod-dev libgpiod2 python3-libgpiod gpiod \\ portaudio19-dev python3-systemd \\ e2fsprogs ntfs-3g exfatprogs \\ console-terminus","title":"System wide packages"},{"location":"installation-steps/#create-a-python-virtual-environment","text":"python3 -m venv ~/.cinemate-env source /home/pi/.cinemate-env/bin/activate echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc","title":"Create a Python virtual environment"},{"location":"installation-steps/#grant-sudo-privileges-and-enable-i2c","text":"echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: sudo reboot","title":"Grant sudo privileges and enable I\u00b2C"},{"location":"installation-steps/#python-packages","text":"If you previously installed the board Python package, remove it with pip3 uninstall board . pip install \\ gpiozero \\ adafruit-blinka adafruit-circuitpython-ssd1306 adafruit-circuitpython-seesaw \\ luma.oled grove.py pigpio-encoder smbus2 rpi_hardware_pwm \\ watchdog psutil pillow redis keyboard pyudev numpy termcolor sounddevice \\ evdev inotify_simple sysv_ipc flask_socketio sugarpie","title":"Python packages"},{"location":"installation-steps/#alternative-gpio-back-end","text":"sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio","title":"Alternative GPIO back-end"},{"location":"installation-steps/#clone-the-cinemate-repo","text":"git clone https://github.com/Tiramisioux/cinemate.git","title":"Clone the Cinemate repo"},{"location":"installation-steps/#allow-cinemate-to-run-with-sudo","text":"Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter.","title":"Allow Cinemate to run with sudo"},{"location":"installation-steps/#enable-networkmanager","text":"sudo systemctl enable NetworkManager --now","title":"Enable NetworkManager"},{"location":"installation-steps/#rotate-logs","text":"Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP","title":"Rotate logs"},{"location":"installation-steps/#seed-redis-with-default-keys","text":"redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 3 .5,1.5 \\ file_size 0 fps 24 fps_actual 24 fps_last 24 fps_max 1 fps_user 24 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 100 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ wb 5600 wb_user 5600 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 (See the settings guide for the full list.)","title":"Seed Redis with default keys"},{"location":"installation-steps/#add-aliases","text":"nano ~/.bashrc Add to the end of the file: alias cinemate = 'python3 /home/pi/cinemate/src/main.py' alias editboot = 'sudo nano /boot/firmware/config.txt' alias editsettings = 'sudo nano /home/pi/cinemate/src/settings.json' Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Reload .bashrc source ~/.bashrc","title":"Add aliases"},{"location":"installation-steps/#cinemate-services","text":"","title":"Cinemate services"},{"location":"installation-steps/#storage-automount","text":"Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT.","title":"storage-automount"},{"location":"installation-steps/#wifi-hotspot","text":"Keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI while in the field. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make start # starts the service sudo make enable # makes the service start on boot You can also start and enable the service individually, by entering their respective folders and issuing the sudo make command Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] During development/building your rig you might prefer the Pi to use your normal Wi\u2011Fi instead of its own hotspot so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false in settings.json and by stopping the service with: sudo systemctl stop wifi-hotspot To stop the hotspot from starting on boot, type sudo systemctl disable wifi-hotspot See Hotspot logic for more details on how the hotspot works.","title":"wifi-hotspot"},{"location":"installation-steps/#connect-to-the-pi-if-not-already-connected","text":"ssh pi@10.42.0.1 password: 1","title":"Connect to the Pi (if not already connected):"},{"location":"installation-steps/#starting-cinemate","text":"Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service:","title":"Starting Cinemate"},{"location":"installation-steps/#cinemate-autostartservice","text":"cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. Tip: sudo make install also places /usr/local/bin/camera-ready.sh on the system. The script waits for cinepi-raw to report a camera before systemd launches Cinemate, preventing the black-screen-on-boot issue that occurred when the GUI started before the sensor initialised. You now have a 12 bit RAW image capturing system on your Raspberry Pi!","title":"cinemate-autostart.service"},{"location":"known-issues/","text":"","title":"Known issues"},{"location":"links/","text":"","title":"Links"},{"location":"overclocking/","text":"Overclocking the Pi #","title":"Overclocking the Pi"},{"location":"overclocking/#overclocking-the-pi","text":"","title":"Overclocking the Pi"},{"location":"overview/","text":"Overview # Note TBA !!! example bash cinemate-cli --init --profile=4k60","title":"Overview"},{"location":"overview/#overview","text":"Note TBA !!! example bash cinemate-cli --init --profile=4k60","title":"Overview"},{"location":"preinstalled-hardware/","text":"Hardware overview # CineMate image file comes pre-installed with: - StarlightEye - CFE Hat - Grove Base HAT","title":"Hardware overview"},{"location":"preinstalled-hardware/#hardware-overview","text":"CineMate image file comes pre-installed with: - StarlightEye - CFE Hat - Grove Base HAT","title":"Hardware overview"},{"location":"readme/","text":"What is it? # Cinemate is a boilerplate cinema camera system for Raspberry Pi 5 building on CinePi\u2011RAW recorder by Csaba Nagy for enabling 12 bit (or even 16 bit) Cinema DNG recordings using off-the-shelf components. Cinemate provides a minimal starting point that you can extend with your own controls and accessories. The project combines a Python UI with a custom fork of cinepi-raw . Figure 1: Camera stack exploded view. Apps change settings by updating Redis keys. CinePi-RAW listens for those updates and captures frames accordingly while Cinemate provides the camera user interface. New features in version 3.2 # improved mounting mechanics for NVME and SSD drives with less drop frames storage preroll to \"warm up\" the recording media, improving writing stability improved audio sync with correction of effective fps (different resolutions/frame rates due to sensor VBLANK), available for fine tuning in src/module/sensor_correction_factors.py option to record a fixed number of frames or seconds for user calibration of fps correction factors (run Cinemate manually for this calibration as feedback is supplied in the terminal) system startup fix to have Cinemate wait for sensor to be loaded properly by the system (contribution from user Yabbo01) simple GUI now supports different resolutions defined by the user in setting.json (contribution from user 0point) Installation # See the releases section for preinstalled image file and Quick Start Guide . For manual install of the camera stack on Raspberry Pi Bookworm, see the here . Compatible sensors # IMX477 (official Raspberry Pi HQ camera) IMX294 (official Raspberry Pi GS camera) IMX585 ( Starlight Eye by Will Whang) IMX283 ( OneInchEye by Will Whang) Preinstalled hardware # CFE Hat Grove Base Hat Adafruit I2C Quad Rotary Encoder Customization # Buttons, encoders and oled display are optional and configured via the settings file . Join the CinePi Discord for discussions and sharing builds. Supporting the project #","title":"Introduction"},{"location":"readme/#what-is-it","text":"Cinemate is a boilerplate cinema camera system for Raspberry Pi 5 building on CinePi\u2011RAW recorder by Csaba Nagy for enabling 12 bit (or even 16 bit) Cinema DNG recordings using off-the-shelf components. Cinemate provides a minimal starting point that you can extend with your own controls and accessories. The project combines a Python UI with a custom fork of cinepi-raw . Figure 1: Camera stack exploded view. Apps change settings by updating Redis keys. CinePi-RAW listens for those updates and captures frames accordingly while Cinemate provides the camera user interface.","title":"What is it?"},{"location":"readme/#new-features-in-version-32","text":"improved mounting mechanics for NVME and SSD drives with less drop frames storage preroll to \"warm up\" the recording media, improving writing stability improved audio sync with correction of effective fps (different resolutions/frame rates due to sensor VBLANK), available for fine tuning in src/module/sensor_correction_factors.py option to record a fixed number of frames or seconds for user calibration of fps correction factors (run Cinemate manually for this calibration as feedback is supplied in the terminal) system startup fix to have Cinemate wait for sensor to be loaded properly by the system (contribution from user Yabbo01) simple GUI now supports different resolutions defined by the user in setting.json (contribution from user 0point)","title":"New features in version 3.2"},{"location":"readme/#installation","text":"See the releases section for preinstalled image file and Quick Start Guide . For manual install of the camera stack on Raspberry Pi Bookworm, see the here .","title":"Installation"},{"location":"readme/#compatible-sensors","text":"IMX477 (official Raspberry Pi HQ camera) IMX294 (official Raspberry Pi GS camera) IMX585 ( Starlight Eye by Will Whang) IMX283 ( OneInchEye by Will Whang)","title":"Compatible sensors"},{"location":"readme/#preinstalled-hardware","text":"CFE Hat Grove Base Hat Adafruit I2C Quad Rotary Encoder","title":"Preinstalled hardware"},{"location":"readme/#customization","text":"Buttons, encoders and oled display are optional and configured via the settings file . Join the CinePi Discord for discussions and sharing builds.","title":"Customization"},{"location":"readme/#supporting-the-project","text":"","title":"Supporting the project"},{"location":"redis-guide/","text":"Redis API quick start # Redis-cli # # List all keys redis-cli KEYS '*' # Read the current ISO value redis-cli GET iso # Start a recording (same as pressing the Rec button) redis-cli SET is_recording 1 redis-cli PUBLISH cp_controls is_recording You can also type: redis-cli This will open the redis cli. cp_controls # Both CinePi-raw and Cinemate writes values and immediately publish the key name. The recorder only reacts when it receives that publish event. Any key may be sent this way. For example, to adjust the preview zoom: # Set preview zoom level redis-cli SET zoom 1 .5 redis-cli PUBLISH cp_controls zoom Note that for the is_recording key Cinemate stops recording upon edge detection (the variable changes from 0 to 1 or vice versa). The reason for this exception has to do with how the CinePi-raw fork handles recording with multiple cameras # Start recording redis-cli SET is_recording 1 # triggers 0 \u2192 1 edge # Stop recording redis-cli SET is_recording 0 # triggers 1 \u2192 0 edge cp_stats # Every frame, cinepi-raw sends a small JSON object containing live statistics. Json :: Value data ; Json :: Value histo ; data [ \"framerate\" ] = completed_request -> framerate ; data [ \"colorTemp\" ] = info . colorTemp ; data [ \"focus\" ] = info . focus ; data [ \"frameCount\" ] = app_ -> GetEncoder () -> getFrameCount (); data [ \"bufferSize\" ] = app_ -> GetEncoder () -> bufferSize (); // per-camera timestamps in nanoseconds data [ \"timestamp\" ] = info . timestamp ; // single sensor data [ \"timestamp_cam0\" ] = info . timestamp_cam0 ; // multi-sensor data [ \"timestamp_cam1\" ] = info . timestamp_cam1 ; // multi-sensor redis_ -> publish ( CHANNEL_STATS , data . toStyledString ()); CineMate\u2019s RedisListener parses these messages and updates Redis keys like framecount , BUFFER and fps_actual . The timestamp fields are converted to SMPTE timecode based on fps_user and written to tc_cam0 and tc_cam1 . Values are only updated when the underlying timestamp changes so Redis clients receive a new timecode once per frame. Controlling the camera from your own script # Below is a very small example using redis-py . import redis r = redis . Redis ( host = 'localhost' , port = 6379 , db = 0 ) # toggle recording current = r . get ( 'is_recording' ) new_value = b '0' if current == b '1' else b '1' r . set ( 'is_recording' , new_value ) r . publish ( 'cp_controls' , 'is_recording' ) Note that in this example, the publishing of the is_recording key is not strictly needed for recording to start/stop, but for formality's sake I think we should keep the publish command. Info This is basically what Cinemate does: it keeps track of variables being set by cinepi-raw, and also sets variables itself.","title":"Redis API"},{"location":"redis-guide/#redis-api-quick-start","text":"","title":"Redis API quick start"},{"location":"redis-guide/#redis-cli","text":"# List all keys redis-cli KEYS '*' # Read the current ISO value redis-cli GET iso # Start a recording (same as pressing the Rec button) redis-cli SET is_recording 1 redis-cli PUBLISH cp_controls is_recording You can also type: redis-cli This will open the redis cli.","title":"Redis-cli"},{"location":"redis-guide/#cp_controls","text":"Both CinePi-raw and Cinemate writes values and immediately publish the key name. The recorder only reacts when it receives that publish event. Any key may be sent this way. For example, to adjust the preview zoom: # Set preview zoom level redis-cli SET zoom 1 .5 redis-cli PUBLISH cp_controls zoom Note that for the is_recording key Cinemate stops recording upon edge detection (the variable changes from 0 to 1 or vice versa). The reason for this exception has to do with how the CinePi-raw fork handles recording with multiple cameras # Start recording redis-cli SET is_recording 1 # triggers 0 \u2192 1 edge # Stop recording redis-cli SET is_recording 0 # triggers 1 \u2192 0 edge","title":"cp_controls"},{"location":"redis-guide/#cp_stats","text":"Every frame, cinepi-raw sends a small JSON object containing live statistics. Json :: Value data ; Json :: Value histo ; data [ \"framerate\" ] = completed_request -> framerate ; data [ \"colorTemp\" ] = info . colorTemp ; data [ \"focus\" ] = info . focus ; data [ \"frameCount\" ] = app_ -> GetEncoder () -> getFrameCount (); data [ \"bufferSize\" ] = app_ -> GetEncoder () -> bufferSize (); // per-camera timestamps in nanoseconds data [ \"timestamp\" ] = info . timestamp ; // single sensor data [ \"timestamp_cam0\" ] = info . timestamp_cam0 ; // multi-sensor data [ \"timestamp_cam1\" ] = info . timestamp_cam1 ; // multi-sensor redis_ -> publish ( CHANNEL_STATS , data . toStyledString ()); CineMate\u2019s RedisListener parses these messages and updates Redis keys like framecount , BUFFER and fps_actual . The timestamp fields are converted to SMPTE timecode based on fps_user and written to tc_cam0 and tc_cam1 . Values are only updated when the underlying timestamp changes so Redis clients receive a new timecode once per frame.","title":"cp_stats"},{"location":"redis-guide/#controlling-the-camera-from-your-own-script","text":"Below is a very small example using redis-py . import redis r = redis . Redis ( host = 'localhost' , port = 6379 , db = 0 ) # toggle recording current = r . get ( 'is_recording' ) new_value = b '0' if current == b '1' else b '1' r . set ( 'is_recording' , new_value ) r . publish ( 'cp_controls' , 'is_recording' ) Note that in this example, the publishing of the is_recording key is not strictly needed for recording to start/stop, but for formality's sake I think we should keep the publish command. Info This is basically what Cinemate does: it keeps track of variables being set by cinepi-raw, and also sets variables itself.","title":"Controlling the camera from your own script"},{"location":"redis-keys/","text":"Redis key reference # This page lists all Redis keys used by Cinemate and CinePi-raw. Values are simple strings so you can read or write them with redis-cli . Each entry explains which component normally writes the key and what happens when you change it manually. Key Written by Description Safe to change manually? anamorphic_factor Cinemate Preview squeeze for anamorphic lenses Yes (publish key to apply) iso Cinemate \u2192 CinePi-raw Sensor gain in ISO Yes shutter_a Cinemate \u2192 CinePi-raw Actual shutter angle in degrees Yes shutter_angle_nom Cinemate Desired shutter angle before sync/free adjustments Yes shutter_a_sync_mode Cinemate Keep exposure constant when changing FPS Yes fps Cinemate \u2192 CinePi-raw Target frames per second Yes sensor_mode Cinemate \u2192 CinePi-raw startup Active sensor resolution/mode Yes (causes pipeline restart) wb Cinemate \u2192 CinePi-raw White\u2011balance temperature (Kelvin) Yes zoom Cinemate Digital zoom for preview streams Yes ir_filter Cinemate \u2192 CinePi-raw Toggle IR\u2011cut filter (IMX585 only) Yes rec / is_recording Cinemate \u2192 CinePi-raw Start/stop recording when toggled Yes (edge\u2011triggered) bit_depth Cinemate \u2192 CinePi-raw startup Sensor bit depth (10 or 12) No (set at startup) height / width Cinemate \u2192 CinePi-raw startup Active sensor resolution No lores_width / lores_height CinePi-raw startup Preview stream resolution No cg_rb Cinemate \u2192 CinePi-raw White\u2011balance gain pair \"1/R,1/B\" Yes (advanced) fps_user Cinemate Temporary storage for the UI slider No fps_last Cinemate Previous stable fps from stats No fps_actual CinePi-raw \u2192 Cinemate Measured FPS from pipeline No framecount CinePi-raw \u2192 Cinemate Total frames recorded No buffer CinePi-raw \u2192 Cinemate Raw frames currently in RAM No buffer_size CinePi-raw \u2192 Cinemate Size of RAM buffer in frames No is_buffering CinePi-raw \u2192 Cinemate 1 while buffer pre\u2011fills No is_writing CinePi-raw \u2192 Cinemate 1 while frames are flushing to disk No is_writing_buf Cinemate Internal countdown after recording stops No is_mounted Cinemate (SSD monitor) 1 when storage is mounted No storage_type Cinemate (SSD monitor) Drive type (NVME/USB/SD) No space_left Cinemate (SSD monitor) Remaining space in GB No write_speed_to_drive Cinemate (SSD monitor) Current write speed MB/s No file_size Cinemate Bytes per frame for current mode No last_dng_cam0/1 CinePi-raw \u2192 Cinemate Path to last written DNG frame No recording_time Cinemate HH:MM:SS:FF timer while recording No memory_alert Cinemate 1 if RAM usage high No cam_init CinePi-raw Internal flag during startup No cameras CinePi-raw JSON list of detected cameras No gui_layout Cinemate Path to GUI layout preset No pi_model Cinemate Raspberry Pi model string No sensor CinePi-raw Active camera model No tc_cam0/tc_cam1 CinePi-raw \u2192 Cinemate SMPTE time code per camera (derived from timestamp* fields) No shutter_angle_actual Cinemate Calculated shutter angle applied after clamping or sync No shutter_angle_transient Cinemate Temporary value during ramping No exposure_time Cinemate Current exposure time in seconds No wb_user Cinemate Kelvin value set before converting to cg_rb No","title":"Key reference"},{"location":"redis-keys/#redis-key-reference","text":"This page lists all Redis keys used by Cinemate and CinePi-raw. Values are simple strings so you can read or write them with redis-cli . Each entry explains which component normally writes the key and what happens when you change it manually. Key Written by Description Safe to change manually? anamorphic_factor Cinemate Preview squeeze for anamorphic lenses Yes (publish key to apply) iso Cinemate \u2192 CinePi-raw Sensor gain in ISO Yes shutter_a Cinemate \u2192 CinePi-raw Actual shutter angle in degrees Yes shutter_angle_nom Cinemate Desired shutter angle before sync/free adjustments Yes shutter_a_sync_mode Cinemate Keep exposure constant when changing FPS Yes fps Cinemate \u2192 CinePi-raw Target frames per second Yes sensor_mode Cinemate \u2192 CinePi-raw startup Active sensor resolution/mode Yes (causes pipeline restart) wb Cinemate \u2192 CinePi-raw White\u2011balance temperature (Kelvin) Yes zoom Cinemate Digital zoom for preview streams Yes ir_filter Cinemate \u2192 CinePi-raw Toggle IR\u2011cut filter (IMX585 only) Yes rec / is_recording Cinemate \u2192 CinePi-raw Start/stop recording when toggled Yes (edge\u2011triggered) bit_depth Cinemate \u2192 CinePi-raw startup Sensor bit depth (10 or 12) No (set at startup) height / width Cinemate \u2192 CinePi-raw startup Active sensor resolution No lores_width / lores_height CinePi-raw startup Preview stream resolution No cg_rb Cinemate \u2192 CinePi-raw White\u2011balance gain pair \"1/R,1/B\" Yes (advanced) fps_user Cinemate Temporary storage for the UI slider No fps_last Cinemate Previous stable fps from stats No fps_actual CinePi-raw \u2192 Cinemate Measured FPS from pipeline No framecount CinePi-raw \u2192 Cinemate Total frames recorded No buffer CinePi-raw \u2192 Cinemate Raw frames currently in RAM No buffer_size CinePi-raw \u2192 Cinemate Size of RAM buffer in frames No is_buffering CinePi-raw \u2192 Cinemate 1 while buffer pre\u2011fills No is_writing CinePi-raw \u2192 Cinemate 1 while frames are flushing to disk No is_writing_buf Cinemate Internal countdown after recording stops No is_mounted Cinemate (SSD monitor) 1 when storage is mounted No storage_type Cinemate (SSD monitor) Drive type (NVME/USB/SD) No space_left Cinemate (SSD monitor) Remaining space in GB No write_speed_to_drive Cinemate (SSD monitor) Current write speed MB/s No file_size Cinemate Bytes per frame for current mode No last_dng_cam0/1 CinePi-raw \u2192 Cinemate Path to last written DNG frame No recording_time Cinemate HH:MM:SS:FF timer while recording No memory_alert Cinemate 1 if RAM usage high No cam_init CinePi-raw Internal flag during startup No cameras CinePi-raw JSON list of detected cameras No gui_layout Cinemate Path to GUI layout preset No pi_model Cinemate Raspberry Pi model string No sensor CinePi-raw Active camera model No tc_cam0/tc_cam1 CinePi-raw \u2192 Cinemate SMPTE time code per camera (derived from timestamp* fields) No shutter_angle_actual Cinemate Calculated shutter angle applied after clamping or sync No shutter_angle_transient Cinemate Temporary value during ramping No exposure_time Cinemate Current exposure time in seconds No wb_user Cinemate Kelvin value set before converting to cg_rb No","title":"Redis key reference"},{"location":"sensor.sizes/","text":"Image circles and sensor sizes # What do \u201c1 inch\u201d and \u201c1/2.3 inch\u201d actually mean? # Those fractions are legacy video\u2011tube designations and not the physical diagonal of the sensor. For example: Marketing name Actual diagonal Typical crop factor* \u201cFull\u2011frame\u201d (35\u202fmm stills) 43\u202fmm 1.0\u00d7 (reference) Micro\u2011Four\u2011Thirds 22\u202fmm ~2.0\u00d7 \u201c1 inch\u201d 16\u202fmm ~2.7\u00d7 Raspberry\u202fPi\u202fHQ (IMX477, sold as \u201c1/2.3 inch\u201d) 7.9\u202fmm ~5.6\u00d7 As we can see, the smaller the sensor the larger the crop factor with regards to the 35mm standard reference. C/CS Mounts C and CS lenses were designed for small\u2011format video and security cameras, so their image circles perfectly cover the IMX477. The Raspberry\u202fPi HQ board also has a built\u2011in back\u2011focus adjustment 4 What if I really want wide shots? # You have two realistic options: Speed\u2011boosters and focal reducers These compress a larger image circle down onto the small sensor, regaining some angle of view. They cost more than the camera and introduce extra optical surfaces, but can work in a pinch. A bigger sensor Stepping up to something like the IMX585 (\u201c1/1.2 inch\u201d) cuts the crop factor roughly in half. At that point, adapting Micro\u2011Four\u2011Thirds or vintage 35\u202fmm lenses begins to make practical sense. 5 Buying roadmap for beginners # Start with the stock 6\u202f\u2013\u202f12\u202fmm Raspberry\u202fPi zoom It teaches you which focal lengths you genuinely use. Add one or two vintage C\u2011mount primes Look for 8\u202fmm or 12\u202fmm lenses from brands such as Kern\u2011Paillard, Computar, or Ang\u00e9nieux. They\u2019re small, sharp, and often under \u20ac100. Master back\u2011focus adjustment The HQ board\u2019s silver ring lets you dial in infinity focus without spacers\u2014a lifesaver when swapping lenses. Only then consider adapters If you\u2019re bumping into the limits of the sensor rather than the lens, that\u2019s the signal to explore larger sensors like the IMX585 plus an MFT or EF adapter. 6 Rules of thumb (bookmark these) # Focal length math: Effective 35\u202fmm focal length = Lens focal length \u00d7 Crop factor . (e.g., 12\u202fmm \u00d7 5.6 \u2248 67\u202fmm portrait.) Image circle > sensor diagonal. If the spec sheet doesn\u2019t list it, assume C/CS lenses cover up to 11\u202fmm and nothing larger. Big\u2011sensor lenses on tiny sensors \u2260 better image. Quality comes from glass matched to the sensor, not size alone. TL;DR # For the Raspberry\u202fPi HQ camera (IMX477), vintage C\u2011mount lenses are your best friends \u2014they cover the sensor perfectly, cost little, and keep the rig small. If you crave a wider field of view or shallower depth of field that feels \u201ccinematic,\u201d consider upgrading the sensor itself (e.g., IMX585) before chasing exotic adapters and full\u2011frame glass. Happy shooting, and may your pixels always land exactly where you intend!","title":"Image circles and sensor sizes"},{"location":"sensor.sizes/#image-circles-and-sensor-sizes","text":"","title":"Image circles and sensor sizes"},{"location":"sensor.sizes/#what-do-1-inch-and-123-inch-actually-mean","text":"Those fractions are legacy video\u2011tube designations and not the physical diagonal of the sensor. For example: Marketing name Actual diagonal Typical crop factor* \u201cFull\u2011frame\u201d (35\u202fmm stills) 43\u202fmm 1.0\u00d7 (reference) Micro\u2011Four\u2011Thirds 22\u202fmm ~2.0\u00d7 \u201c1 inch\u201d 16\u202fmm ~2.7\u00d7 Raspberry\u202fPi\u202fHQ (IMX477, sold as \u201c1/2.3 inch\u201d) 7.9\u202fmm ~5.6\u00d7 As we can see, the smaller the sensor the larger the crop factor with regards to the 35mm standard reference. C/CS Mounts C and CS lenses were designed for small\u2011format video and security cameras, so their image circles perfectly cover the IMX477. The Raspberry\u202fPi HQ board also has a built\u2011in back\u2011focus adjustment","title":"What do \u201c1 inch\u201d and \u201c1/2.3 inch\u201d actually mean?"},{"location":"sensor.sizes/#4-what-if-i-really-want-wide-shots","text":"You have two realistic options: Speed\u2011boosters and focal reducers These compress a larger image circle down onto the small sensor, regaining some angle of view. They cost more than the camera and introduce extra optical surfaces, but can work in a pinch. A bigger sensor Stepping up to something like the IMX585 (\u201c1/1.2 inch\u201d) cuts the crop factor roughly in half. At that point, adapting Micro\u2011Four\u2011Thirds or vintage 35\u202fmm lenses begins to make practical sense.","title":"4 What if I really want wide shots?"},{"location":"sensor.sizes/#5-buying-roadmap-for-beginners","text":"Start with the stock 6\u202f\u2013\u202f12\u202fmm Raspberry\u202fPi zoom It teaches you which focal lengths you genuinely use. Add one or two vintage C\u2011mount primes Look for 8\u202fmm or 12\u202fmm lenses from brands such as Kern\u2011Paillard, Computar, or Ang\u00e9nieux. They\u2019re small, sharp, and often under \u20ac100. Master back\u2011focus adjustment The HQ board\u2019s silver ring lets you dial in infinity focus without spacers\u2014a lifesaver when swapping lenses. Only then consider adapters If you\u2019re bumping into the limits of the sensor rather than the lens, that\u2019s the signal to explore larger sensors like the IMX585 plus an MFT or EF adapter.","title":"5 Buying roadmap for beginners"},{"location":"sensor.sizes/#6-rules-of-thumb-bookmark-these","text":"Focal length math: Effective 35\u202fmm focal length = Lens focal length \u00d7 Crop factor . (e.g., 12\u202fmm \u00d7 5.6 \u2248 67\u202fmm portrait.) Image circle > sensor diagonal. If the spec sheet doesn\u2019t list it, assume C/CS lenses cover up to 11\u202fmm and nothing larger. Big\u2011sensor lenses on tiny sensors \u2260 better image. Quality comes from glass matched to the sensor, not size alone.","title":"6 Rules of thumb (bookmark these)"},{"location":"sensor.sizes/#tldr","text":"For the Raspberry\u202fPi HQ camera (IMX477), vintage C\u2011mount lenses are your best friends \u2014they cover the sensor perfectly, cost little, and keep the rig small. If you crave a wider field of view or shallower depth of field that feels \u201ccinematic,\u201d consider upgrading the sensor itself (e.g., IMX585) before chasing exotic adapters and full\u2011frame glass. Happy shooting, and may your pixels always land exactly where you intend!","title":"TL;DR"},{"location":"sensors/","text":"Compatible sensors # IMX477 (Raspberry Pi HQ Camera) # Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 2028 x 1080 1.87 12 50 4.3 1 2028 x 1520 1.33 12 40 5.3 2 1332 x 990 1.34 10 120 2.7 IMX296 (Raspberry Pi Global Shutter Camera) # Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 1456 x 1088 1.33 12 60 3.1 IMX585 (Starlight Eye) # Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 1928 x 1090 1.77 12 87 4.0 1 3840 x 2160 1.77 12 34 4.0 IMX283 (OneInchEye) # Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 2736 x 1538 1.80 12 40 7.1 1 2736 x 1824 1.53 12 34 8.2 Note that maximum fps will vary according to disk write speed. For the specific fps values for your setup, make test recordings and monitor the output. Purple background in the monitor/web browser indicates drop frames. You can limit which modes appear inside CineMate by editing the resolutions section in settings.json . k_steps are approximate resolution steps. Custom driver modes can also be added here. \"resolutions\" : { \"k_steps\" : [ 1.5 , 2 , 4 ], \"bit_depths\" : [ 10 , 12 ], \"custom_modes\" : { \"imx283\" : [ { \"width\" : 3936 , \"height\" : 2176 , \"bit_depth\" : 12 , \"fps_max\" : 24 } ] } } The dng_encoder in Cinemate fork of Cinepi-RAW currently outputs all modes as 12 bit DNG. Sustainable frame rates # For continouos recording without the system utilizing the frame buffer and with no drop frames. Performance will depend on sensor and storage media. Here are measured results. IMX477 # Resolution Bit Depth Storage Sustainable FPS 2028 x 1080 12 bit SSD (Samsung T7) 34 2028 x 1520 12 bit SSD (Samsung T7) 24 1332 x 990 12 bit SSD (Samsung T7) 71 2028 x 1080 12 bit CFE Hat / NVMe 50 2028 x 1520 12 bit CFE Hat / NVMe 40 1332 x 990 12 bit CFE Hat / NVMe 119 IMX585 # Resolution Bit Depth Storage Sustainable FPS 1928 x 1090 12 bit SSD (Samsung T7) 33 3856 x 2180 12 bit SSD (Samsung T7) 10 1928 x 1090 12 bit CFE Hat / NVMe 87 3856 x 2180 12 bit CFE Hat / NVMe 43 Note that the frame buffer is occationally used, especially for SSD drives, due to occational drop in write speed.","title":"Camera sensors and frame rates"},{"location":"sensors/#compatible-sensors","text":"","title":"Compatible sensors"},{"location":"sensors/#imx477-raspberry-pi-hq-camera","text":"Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 2028 x 1080 1.87 12 50 4.3 1 2028 x 1520 1.33 12 40 5.3 2 1332 x 990 1.34 10 120 2.7","title":"IMX477 (Raspberry Pi HQ Camera)"},{"location":"sensors/#imx296-raspberry-pi-global-shutter-camera","text":"Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 1456 x 1088 1.33 12 60 3.1","title":"IMX296 (Raspberry Pi Global Shutter Camera)"},{"location":"sensors/#imx585-starlight-eye","text":"Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 1928 x 1090 1.77 12 87 4.0 1 3840 x 2160 1.77 12 34 4.0","title":"IMX585 (Starlight Eye)"},{"location":"sensors/#imx283-oneincheye","text":"Mode Resolution Aspect Ratio Bit Depth Max FPS DNG Frame File Size (MB) 0 2736 x 1538 1.80 12 40 7.1 1 2736 x 1824 1.53 12 34 8.2 Note that maximum fps will vary according to disk write speed. For the specific fps values for your setup, make test recordings and monitor the output. Purple background in the monitor/web browser indicates drop frames. You can limit which modes appear inside CineMate by editing the resolutions section in settings.json . k_steps are approximate resolution steps. Custom driver modes can also be added here. \"resolutions\" : { \"k_steps\" : [ 1.5 , 2 , 4 ], \"bit_depths\" : [ 10 , 12 ], \"custom_modes\" : { \"imx283\" : [ { \"width\" : 3936 , \"height\" : 2176 , \"bit_depth\" : 12 , \"fps_max\" : 24 } ] } } The dng_encoder in Cinemate fork of Cinepi-RAW currently outputs all modes as 12 bit DNG.","title":"IMX283 (OneInchEye)"},{"location":"sensors/#sustainable-frame-rates","text":"For continouos recording without the system utilizing the frame buffer and with no drop frames. Performance will depend on sensor and storage media. Here are measured results.","title":"Sustainable frame rates"},{"location":"sensors/#imx477","text":"Resolution Bit Depth Storage Sustainable FPS 2028 x 1080 12 bit SSD (Samsung T7) 34 2028 x 1520 12 bit SSD (Samsung T7) 24 1332 x 990 12 bit SSD (Samsung T7) 71 2028 x 1080 12 bit CFE Hat / NVMe 50 2028 x 1520 12 bit CFE Hat / NVMe 40 1332 x 990 12 bit CFE Hat / NVMe 119","title":"IMX477"},{"location":"sensors/#imx585","text":"Resolution Bit Depth Storage Sustainable FPS 1928 x 1090 12 bit SSD (Samsung T7) 33 3856 x 2180 12 bit SSD (Samsung T7) 10 1928 x 1090 12 bit CFE Hat / NVMe 87 3856 x 2180 12 bit CFE Hat / NVMe 43 Note that the frame buffer is occationally used, especially for SSD drives, due to occational drop in write speed.","title":"IMX585"},{"location":"settings-json/","text":"Settings file # This file controls how the camera behaves and how your buttons, switches and displays are mapped. It lives in ~/cinemate/src/settings.json . You can edit it with any text editor; the settings take effect the next time you start Cinemate. For easy editing of settings on the preinstalled image file, type editsettings anywhere in Raspberry Pi terminal. The configuration is structured as JSON. Each top\u2011level key describes a feature area of the system. Below is a tour of every section and what the options do. welcome message # Text or image displayed briefly when Cinemate starts. \"welcome_image\" : null \"welcome_message\" : \"THIS IS A COOL MACHINE\" , Set welcome_image to the path of a bitmap file to show a logo instead of text. Example path: /home/pi/welcome_image.bmp . If welcome image path is set, this will override the text message. system # \"system\" : { \"wifi_hotspot\" : { \"name\" : \"CinePi\" , \"password\" : \"11111111\" , \"enabled\" : false } } name \u2013 the Wi\u2011Fi network name (SSID) broadcast by the Pi when hotspot mode is enabled. password \u2013 password for joining the hotspot. enabled \u2013 set to true to start the hotspot automatically on boot. If set to false , CineMate will still start its web ui but stream it on whatever network the Pi is connected to. Use the hotspot when you need a direct connection in the field. Disable it during development so the Pi can join your regular Wi\u2011Fi and reach the internet. If you are connected to the Pi via Ethernet you can keep the hotspot on. geometry # Controls image orientation for each camera port ( cam0 , cam1 , etc.). These settings let you mount cameras in any orientation and still get an upright preview and recording. Example: \"geometry\" : { \"cam0\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false }, \"cam1\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false } } rotate_180 \u2013 flip the image upside\u2011down. horizontal_flip \u2013 mirror the image left/right. vertical_flip \u2013 mirror the image top/bottom. output # Maps each camera to an HDMI connector. Use -1 for automatic selection. \"output\" : { \"cam0\" : { \"hdmi_port\" : 0 }, \"cam1\" : { \"hdmi_port\" : 1 } } preview # Adjusts zoom levels for the HDMI/browser preview. \"preview\" : { \"default_zoom\" : 1.0 , \"zoom_steps\" : [ 1.0 , 1.5 , 2.0 ] } default_zoom \u2013 magnification factor used at startup. zoom_steps \u2013 list of zoom factors you can cycle through with the set_zoom_step command. anamorphic_preview # For stretching the preview when using anamorphic lenses. \"anamorphic_preview\" : { \"default_anamorphic_factor\" : 1 , \"anamorphic_steps\" : [ 1 , 1.33 , 2.0 ] } default_anamorphic_factor \u2013 factor loaded when Cinemate starts. anamorphic_steps \u2013 selectable squeeze factors; values above 1.0 widen the image. gpio_output # Defines pins used for visual feedback or sync signals. \"gpio_output\" : { \"pwm_pin\" : 19 , \"rec_out_pin\" : [ 6 , 21 ] } pwm_pin \u2013 outputs a strobe for shutter sync or external devices. rec_out_pin \u2013 list of pins pulled high while recording (useful for tally LEDs). arrays # Preset lists for exposure and frame\u2011rate settings. Cinemate will step through these values unless you enable free mode, either in the settings file or during runtime. \"arrays\" : { \"iso_steps\" : [ 100 , 200 , 400 , 640 , 800 , 1200 , 1600 , 2500 , 3200 ], \"shutter_a_steps\" : [ 1 , 45 , 90 , 135 , 172.8 , 180 , 225 , 270 , 315 , 346.6 , 360 ], \"fps_steps\" : [ 1 , 2 , 4 , 8 , 12 , 16 , 18 , 24 , 25 , 33 , 40 , 50 ], \"wb_steps\" : [ 3200 , 4400 , 5600 ] } settings # General options for runtime behaviour. \"settings\" : { \"light_hz\" : [ 50 , 60 ], \"conform_frame_rate\" : 24 } light_hz \u2013 list of mains frequencies used to calculate flicker\u2011free shutter angles. These are added to the shutter angle array and also dynamically calculated upon each fps change. This way, there is always a flicker free shutter angle value close by, when toggling through shutter angles, either via the cli or using buttons/pots/rotary encoder. conform_frame_rate \u2013 frame rate intendend for project conforming in post. This setting is not really used by CineMate except for calculating the recording timecode tracker in redis but might be used in future updates. analog_controls # Maps Grove Base HAT ADC channels to analogue dials (potentiometers). Use null to disable a dial. \"analog_controls\" : { \"iso_pot\" : 0 , \"shutter_a_pot\" : 2 , \"fps_pot\" : 4 , \"wb_pot\" : \"None\" } When using a Grove Base Hat with potentiometers, make sure to define only channels actually connected to potentiometers, since noise from unused connectors might trigger false readings. free_mode # When enabled, ignores the preset arrays and exposes the full range supported by the sensor. \"free_mode\" : { \"iso_free\" : false , \"shutter_a_free\" : false , \"fps_free\" : true , \"wb_free\" : false } resolutions # Limit which sensor modes appear when cycling resolutions. \"resolutions\" : { \"k_steps\" : [ 1.5 , 2 , 4 ], \"bit_depths\" : [ 10 , 12 ], \"custom_modes\" : { \"imx283\" : [ { \"width\" : 3936 , \"height\" : 2176 , \"bit_depth\" : 12 , \"fps_max\" : 24 } ] } } k_steps \u2013 K\u2011style categories for allowed widths. Modes are grouped to the nearest half\u2011K. Example: 1332\u00d7990 counts as 1.5\u202fK . bit_depths \u2013 list of bit depths to expose. custom_modes \u2013 optional extra modes per sensor if the driver advertises none. buttons # Defines GPIO push buttons. Each entry describes one button and the actions it triggers. { \"pin\" : 5 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"rec\" } } pin \u2013 BCM pin number the button is connected to. pull_up \u2013 set true if the pin idles high (internal pull\u2011up). Use false for pull\u2011down wiring. debounce_time \u2013 ignore additional presses within this time window (seconds). press_action , single_click_action , double_click_action , triple_click_action , hold_action \u2013 actions to perform for each type of interaction. Actions call Cinemate CLI commands with optional args . Some push-buttons are wired closed = logic 1 and open = 0. At start-up, CineMate automatically detects buttons in state true and reverses them. This way the user can use any type of push buttons, both 1-0-1 and 0-1-0 types. two_way_switches # Latching on/off switches. Cinemate triggers an action whenever the state changes. { \"pin\" : 27 , \"state_on_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 1 ]}, \"state_off_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 0 ]} } rotary_encoders # Rotary encoders used for fine adjustment of settings. These can be wired straight to the GPIO pins of the Pi. { \"clk_pin\" : 9 , \"dt_pin\" : 11 , \"encoder_actions\" : { \"rotate_clockwise\" : { \"method\" : \"inc_iso\" }, \"rotate_counterclockwise\" : { \"method\" : \"dec_iso\" } } } clk_pin and dt_pin \u2013 the two pins of the encoder. encoder_actions \u2013 commands to run when turning the dial. quad_rotary_controller # Support for the Adafruit Neopixel Quad I2C rotary encoder breakout. Each entry maps one of the four dials to a setting and defines the push button actions similar to the buttons section. \"quad_rotary_controller\" : { \"enabled\" : true , \"encoders\" : { \"0\" : { \"setting_name\" : \"iso\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}}, \"1\" : { \"setting_name\" : \"shutter_a\" , \"button\" : { \"press_action\" : { \"method\" : \"set_fps_double\" }}}, \"2\" : { \"setting_name\" : \"fps\" , \"button\" : { \"press_action\" : \"None\" , \"single_click_action\" : { \"method\" : \"set_resolution\" }, \"double_click_action\" : { \"method\" : \"restart_cinemate\" }, \"triple_click_action\" : { \"method\" : \"reboot\" }, \"hold_action\" : { \"method\" : \"toggle_mount\" } } }, \"3\" : { \"setting_name\" : \"wb\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}} } } enabled \u2013 turn the quad rotary controller on or off. encoders \u2013 mapping of each dial to a setting and button actions. i2c_oled # Configuration for the optional OLED status screen. This can be useful for presenting extra information appart from the HDMI/web display. \"i2c_oled\" : { \"enabled\" : true , \"width\" : 128 , \"height\" : 64 , \"font_size\" : 30 , \"values\" : [ \"write_speed_to_drive\" ] } enabled \u2013 turn the OLED display on or off. width / height \u2013 pixel dimensions of your screen. font_size \u2013 size of the displayed text. values \u2013 list of Redis keys or pseudo\u2011keys to show (for example cpu_temp ). Available keys come from src/module/i2c/i2c_oled.py . Here are some examples: iso , fps \u2013 basic camera settings. shutter_a \u2013 shown as SHUTTER with a \u00b0 suffix. wb_user \u2013 shown as WB with a trailing K . space_left \u2013 displayed as SPACE in gigabytes. write_speed_to_drive \u2013 write speed in MB/s. resolution \u2013 prints width\u00d7height@bit_depth on the first line. is_recording \u2013 draws a bullet \u25cf when recording. cpu_load , cpu_temp , memory_usage \u2013 Pi system statistics. Other keys will display their name in uppercase and the raw value from Redis.","title":"Custom settings"},{"location":"settings-json/#settings-file","text":"This file controls how the camera behaves and how your buttons, switches and displays are mapped. It lives in ~/cinemate/src/settings.json . You can edit it with any text editor; the settings take effect the next time you start Cinemate. For easy editing of settings on the preinstalled image file, type editsettings anywhere in Raspberry Pi terminal. The configuration is structured as JSON. Each top\u2011level key describes a feature area of the system. Below is a tour of every section and what the options do.","title":"Settings file"},{"location":"settings-json/#welcome-message","text":"Text or image displayed briefly when Cinemate starts. \"welcome_image\" : null \"welcome_message\" : \"THIS IS A COOL MACHINE\" , Set welcome_image to the path of a bitmap file to show a logo instead of text. Example path: /home/pi/welcome_image.bmp . If welcome image path is set, this will override the text message.","title":"welcome message"},{"location":"settings-json/#system","text":"\"system\" : { \"wifi_hotspot\" : { \"name\" : \"CinePi\" , \"password\" : \"11111111\" , \"enabled\" : false } } name \u2013 the Wi\u2011Fi network name (SSID) broadcast by the Pi when hotspot mode is enabled. password \u2013 password for joining the hotspot. enabled \u2013 set to true to start the hotspot automatically on boot. If set to false , CineMate will still start its web ui but stream it on whatever network the Pi is connected to. Use the hotspot when you need a direct connection in the field. Disable it during development so the Pi can join your regular Wi\u2011Fi and reach the internet. If you are connected to the Pi via Ethernet you can keep the hotspot on.","title":"system"},{"location":"settings-json/#geometry","text":"Controls image orientation for each camera port ( cam0 , cam1 , etc.). These settings let you mount cameras in any orientation and still get an upright preview and recording. Example: \"geometry\" : { \"cam0\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false }, \"cam1\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false } } rotate_180 \u2013 flip the image upside\u2011down. horizontal_flip \u2013 mirror the image left/right. vertical_flip \u2013 mirror the image top/bottom.","title":"geometry"},{"location":"settings-json/#output","text":"Maps each camera to an HDMI connector. Use -1 for automatic selection. \"output\" : { \"cam0\" : { \"hdmi_port\" : 0 }, \"cam1\" : { \"hdmi_port\" : 1 } }","title":"output"},{"location":"settings-json/#preview","text":"Adjusts zoom levels for the HDMI/browser preview. \"preview\" : { \"default_zoom\" : 1.0 , \"zoom_steps\" : [ 1.0 , 1.5 , 2.0 ] } default_zoom \u2013 magnification factor used at startup. zoom_steps \u2013 list of zoom factors you can cycle through with the set_zoom_step command.","title":"preview"},{"location":"settings-json/#anamorphic_preview","text":"For stretching the preview when using anamorphic lenses. \"anamorphic_preview\" : { \"default_anamorphic_factor\" : 1 , \"anamorphic_steps\" : [ 1 , 1.33 , 2.0 ] } default_anamorphic_factor \u2013 factor loaded when Cinemate starts. anamorphic_steps \u2013 selectable squeeze factors; values above 1.0 widen the image.","title":"anamorphic_preview"},{"location":"settings-json/#gpio_output","text":"Defines pins used for visual feedback or sync signals. \"gpio_output\" : { \"pwm_pin\" : 19 , \"rec_out_pin\" : [ 6 , 21 ] } pwm_pin \u2013 outputs a strobe for shutter sync or external devices. rec_out_pin \u2013 list of pins pulled high while recording (useful for tally LEDs).","title":"gpio_output"},{"location":"settings-json/#arrays","text":"Preset lists for exposure and frame\u2011rate settings. Cinemate will step through these values unless you enable free mode, either in the settings file or during runtime. \"arrays\" : { \"iso_steps\" : [ 100 , 200 , 400 , 640 , 800 , 1200 , 1600 , 2500 , 3200 ], \"shutter_a_steps\" : [ 1 , 45 , 90 , 135 , 172.8 , 180 , 225 , 270 , 315 , 346.6 , 360 ], \"fps_steps\" : [ 1 , 2 , 4 , 8 , 12 , 16 , 18 , 24 , 25 , 33 , 40 , 50 ], \"wb_steps\" : [ 3200 , 4400 , 5600 ] }","title":"arrays"},{"location":"settings-json/#settings","text":"General options for runtime behaviour. \"settings\" : { \"light_hz\" : [ 50 , 60 ], \"conform_frame_rate\" : 24 } light_hz \u2013 list of mains frequencies used to calculate flicker\u2011free shutter angles. These are added to the shutter angle array and also dynamically calculated upon each fps change. This way, there is always a flicker free shutter angle value close by, when toggling through shutter angles, either via the cli or using buttons/pots/rotary encoder. conform_frame_rate \u2013 frame rate intendend for project conforming in post. This setting is not really used by CineMate except for calculating the recording timecode tracker in redis but might be used in future updates.","title":"settings"},{"location":"settings-json/#analog_controls","text":"Maps Grove Base HAT ADC channels to analogue dials (potentiometers). Use null to disable a dial. \"analog_controls\" : { \"iso_pot\" : 0 , \"shutter_a_pot\" : 2 , \"fps_pot\" : 4 , \"wb_pot\" : \"None\" } When using a Grove Base Hat with potentiometers, make sure to define only channels actually connected to potentiometers, since noise from unused connectors might trigger false readings.","title":"analog_controls"},{"location":"settings-json/#free_mode","text":"When enabled, ignores the preset arrays and exposes the full range supported by the sensor. \"free_mode\" : { \"iso_free\" : false , \"shutter_a_free\" : false , \"fps_free\" : true , \"wb_free\" : false }","title":"free_mode"},{"location":"settings-json/#resolutions","text":"Limit which sensor modes appear when cycling resolutions. \"resolutions\" : { \"k_steps\" : [ 1.5 , 2 , 4 ], \"bit_depths\" : [ 10 , 12 ], \"custom_modes\" : { \"imx283\" : [ { \"width\" : 3936 , \"height\" : 2176 , \"bit_depth\" : 12 , \"fps_max\" : 24 } ] } } k_steps \u2013 K\u2011style categories for allowed widths. Modes are grouped to the nearest half\u2011K. Example: 1332\u00d7990 counts as 1.5\u202fK . bit_depths \u2013 list of bit depths to expose. custom_modes \u2013 optional extra modes per sensor if the driver advertises none.","title":"resolutions"},{"location":"settings-json/#buttons","text":"Defines GPIO push buttons. Each entry describes one button and the actions it triggers. { \"pin\" : 5 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"rec\" } } pin \u2013 BCM pin number the button is connected to. pull_up \u2013 set true if the pin idles high (internal pull\u2011up). Use false for pull\u2011down wiring. debounce_time \u2013 ignore additional presses within this time window (seconds). press_action , single_click_action , double_click_action , triple_click_action , hold_action \u2013 actions to perform for each type of interaction. Actions call Cinemate CLI commands with optional args . Some push-buttons are wired closed = logic 1 and open = 0. At start-up, CineMate automatically detects buttons in state true and reverses them. This way the user can use any type of push buttons, both 1-0-1 and 0-1-0 types.","title":"buttons"},{"location":"settings-json/#two_way_switches","text":"Latching on/off switches. Cinemate triggers an action whenever the state changes. { \"pin\" : 27 , \"state_on_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 1 ]}, \"state_off_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 0 ]} }","title":"two_way_switches"},{"location":"settings-json/#rotary_encoders","text":"Rotary encoders used for fine adjustment of settings. These can be wired straight to the GPIO pins of the Pi. { \"clk_pin\" : 9 , \"dt_pin\" : 11 , \"encoder_actions\" : { \"rotate_clockwise\" : { \"method\" : \"inc_iso\" }, \"rotate_counterclockwise\" : { \"method\" : \"dec_iso\" } } } clk_pin and dt_pin \u2013 the two pins of the encoder. encoder_actions \u2013 commands to run when turning the dial.","title":"rotary_encoders"},{"location":"settings-json/#quad_rotary_controller","text":"Support for the Adafruit Neopixel Quad I2C rotary encoder breakout. Each entry maps one of the four dials to a setting and defines the push button actions similar to the buttons section. \"quad_rotary_controller\" : { \"enabled\" : true , \"encoders\" : { \"0\" : { \"setting_name\" : \"iso\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}}, \"1\" : { \"setting_name\" : \"shutter_a\" , \"button\" : { \"press_action\" : { \"method\" : \"set_fps_double\" }}}, \"2\" : { \"setting_name\" : \"fps\" , \"button\" : { \"press_action\" : \"None\" , \"single_click_action\" : { \"method\" : \"set_resolution\" }, \"double_click_action\" : { \"method\" : \"restart_cinemate\" }, \"triple_click_action\" : { \"method\" : \"reboot\" }, \"hold_action\" : { \"method\" : \"toggle_mount\" } } }, \"3\" : { \"setting_name\" : \"wb\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}} } } enabled \u2013 turn the quad rotary controller on or off. encoders \u2013 mapping of each dial to a setting and button actions.","title":"quad_rotary_controller"},{"location":"settings-json/#i2c_oled","text":"Configuration for the optional OLED status screen. This can be useful for presenting extra information appart from the HDMI/web display. \"i2c_oled\" : { \"enabled\" : true , \"width\" : 128 , \"height\" : 64 , \"font_size\" : 30 , \"values\" : [ \"write_speed_to_drive\" ] } enabled \u2013 turn the OLED display on or off. width / height \u2013 pixel dimensions of your screen. font_size \u2013 size of the displayed text. values \u2013 list of Redis keys or pseudo\u2011keys to show (for example cpu_temp ). Available keys come from src/module/i2c/i2c_oled.py . Here are some examples: iso , fps \u2013 basic camera settings. shutter_a \u2013 shown as SHUTTER with a \u00b0 suffix. wb_user \u2013 shown as WB with a trailing K . space_left \u2013 displayed as SPACE in gigabytes. write_speed_to_drive \u2013 write speed in MB/s. resolution \u2013 prints width\u00d7height@bit_depth on the first line. is_recording \u2013 draws a bullet \u25cf when recording. cpu_load , cpu_temp , memory_usage \u2013 Pi system statistics. Other keys will display their name in uppercase and the raw value from Redis.","title":"i2c_oled"},{"location":"simple-gui/","text":"Simple GUI # Simple GUI is available via browser and/or attached HDMI monitor. Red color means camera is recording. Purple color means camera detected a drop frame Green color means camera is writing buffered frames to disk. You can still start recording at this stage, but any buffered frames from the last recording will be lost. Buffer meter in the lower left indicates number of frames in buffer. Useful when testing storage media. When a compatible USB microphone is connected, VU meters appear on the right side of the GUI so you can monitor audio levels.","title":"Simple GUI"},{"location":"simple-gui/#simple-gui","text":"Simple GUI is available via browser and/or attached HDMI monitor. Red color means camera is recording. Purple color means camera detected a drop frame Green color means camera is writing buffered frames to disk. You can still start recording at this stage, but any buffered frames from the last recording will be lost. Buffer meter in the lower left indicates number of frames in buffer. Useful when testing storage media. When a compatible USB microphone is connected, VU meters appear on the right side of the GUI so you can monitor audio levels.","title":"Simple GUI"},{"location":"speed-ramping/","text":"Speed ramping # Speed ramping is the process of changing the camera's frame rate during a shot so that playback speed varies once the footage is conformed to a constant frame rate in post production. Ramping up the frame rate produces slow motion while ramping down speeds up the action. Speed ramping in Cinemate # Cinemate exposes frame rate control through the CinePiController class. The simplest way to change speed on the fly is the CLI command: set fps <value> For quick 2\u00d7 changes Cinemate also implements set_fps_double which toggles between the current FPS and twice that value. This can be used for designing a slow-motion button. Here is how you would to it in the settings file, button section: { \"pin\" : 18 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"set_fps_double\" } } No argument is needed here. For methods such as set_fps_double , calling the method without an argument will simply toggle the control, in tis caseturning the slow motion on and off. If the user provides an argument, the control will be set explicitly to that value. The controller contains an experimental _ramp_fps helper that gradually steps the frame rate up or down using ramp_up_speed and ramp_down_speed delays. This can be adapted if smoother transitions are desired. Shutter angle synchronisation # When frame rate changes the shutter angle can either remain fixed (preserving motion blur) or adjust to keep the exposure time constant. This behaviour is controlled by shutter_a_sync_mode . Mode 0 keeps the motion blur consistent because the physical shutter angle does not change. As the FPS increases the exposure time gets shorter, resulting in a darker image. Mode 1 stores the current exposure time and recalculates the shutter angle whenever the FPS is adjusted so that exposure time stays the same. Cinemate updates the nominal exposure time when the user sets a new angle. FPS is recalculated from the stored exposure time:","title":"Speed ramping & shutter angle synchronization"},{"location":"speed-ramping/#speed-ramping","text":"Speed ramping is the process of changing the camera's frame rate during a shot so that playback speed varies once the footage is conformed to a constant frame rate in post production. Ramping up the frame rate produces slow motion while ramping down speeds up the action.","title":"Speed ramping"},{"location":"speed-ramping/#speed-ramping-in-cinemate","text":"Cinemate exposes frame rate control through the CinePiController class. The simplest way to change speed on the fly is the CLI command: set fps <value> For quick 2\u00d7 changes Cinemate also implements set_fps_double which toggles between the current FPS and twice that value. This can be used for designing a slow-motion button. Here is how you would to it in the settings file, button section: { \"pin\" : 18 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"set_fps_double\" } } No argument is needed here. For methods such as set_fps_double , calling the method without an argument will simply toggle the control, in tis caseturning the slow motion on and off. If the user provides an argument, the control will be set explicitly to that value. The controller contains an experimental _ramp_fps helper that gradually steps the frame rate up or down using ramp_up_speed and ramp_down_speed delays. This can be adapted if smoother transitions are desired.","title":"Speed ramping in Cinemate"},{"location":"speed-ramping/#shutter-angle-synchronisation","text":"When frame rate changes the shutter angle can either remain fixed (preserving motion blur) or adjust to keep the exposure time constant. This behaviour is controlled by shutter_a_sync_mode . Mode 0 keeps the motion blur consistent because the physical shutter angle does not change. As the FPS increases the exposure time gets shorter, resulting in a darker image. Mode 1 stores the current exposure time and recalculates the shutter angle whenever the FPS is adjusted so that exposure time stays the same. Cinemate updates the nominal exposure time when the user sets a new angle. FPS is recalculated from the stored exposure time:","title":"Shutter angle synchronisation"},{"location":"ssh/","text":"Connecting to the Pi remotely with SSH # Connect your computer and the Pi to the same network. If you are using the preinstalled image file, the system automatically starts a built-in hotspot: join the CinePi Wi\u2011Fi with password 11111111 . You can change this behaviour later in the settings file . Open a terminal (on Windows you can use PowerShell). Try the hostname first: ssh pi@cinepi.local If this fails you can list devices on the network: arp -a Look for an entry labelled cinepi or note the new IP address that appears. Use the hostname or IP address with SSH: ssh pi@cinepi.local # or ssh pi@<ip-address> When asked about the host key, type yes . Enter the default password 1 when prompted. You will now see the pi@cinepi prompt, meaning you are logged in. If you are installing Cinemate manually, the hostname has not yet been set to cinepi. Then you will have to identify which ip address on the network is actually the Raspberry Pi and use that ip address. Type cinemate anywhere in the cli to start the app. If you are running Cinemate from the preinstalled image file, Cinemate is already running, as it autostarts on boot. See here for how to manage the autostart-service .","title":"Connecting via SSH"},{"location":"ssh/#connecting-to-the-pi-remotely-with-ssh","text":"Connect your computer and the Pi to the same network. If you are using the preinstalled image file, the system automatically starts a built-in hotspot: join the CinePi Wi\u2011Fi with password 11111111 . You can change this behaviour later in the settings file . Open a terminal (on Windows you can use PowerShell). Try the hostname first: ssh pi@cinepi.local If this fails you can list devices on the network: arp -a Look for an entry labelled cinepi or note the new IP address that appears. Use the hostname or IP address with SSH: ssh pi@cinepi.local # or ssh pi@<ip-address> When asked about the host key, type yes . Enter the default password 1 when prompted. You will now see the pi@cinepi prompt, meaning you are logged in. If you are installing Cinemate manually, the hostname has not yet been set to cinepi. Then you will have to identify which ip address on the network is actually the Raspberry Pi and use that ip address. Type cinemate anywhere in the cli to start the app. If you are running Cinemate from the preinstalled image file, Cinemate is already running, as it autostarts on boot. See here for how to manage the autostart-service .","title":"Connecting to the Pi remotely with SSH"},{"location":"storage-preroll/","text":"Storage pre-roll warm-up # Cinemate includes an automatic \"storage pre-roll\" that records and discards a short clip to make sure new media can keep up before you roll on something important.\u3010F:src/module/storage_preroll.py\u2020L1-L57\u3011 The warm-up runs the recorder at full speed so SSDs spin up, controllers cache their write tables and the rest of the pipeline has a chance to stabilise. When the pre-roll runs # On startup: after a brief settle delay, the helper checks whether the RAW volume is mounted and triggers a warm-up run if so.\u3010F:src/module/storage_preroll.py\u2020L58-L96\u3011 Whenever storage mounts: the SSD monitor emits an event that immediately schedules another pre-roll so freshly attached drives are exercised before you use them.\u3010F:src/module/storage_preroll.py\u2020L40-L92\u3011 On demand: you can type storage preroll in the Cinemate CLI to queue a run manually. The command is ignored while a pre-roll is already active so repeated presses do not stack up.\u3010F:src/module/cli_commands.py\u2020L64-L72\u3011\u3010F:src/module/storage_preroll.py\u2020L40-L92\u3011 The module keeps a lock so only one warm-up runs at a time and exposes the storage_preroll_active Redis key to let the UI show progress.\u3010F:src/module/storage_preroll.py\u2020L26-L74\u3011 What happens during a run # The helper aborts if no media is mounted or if a real recording is in progress; it will try again after the next trigger.\u3010F:src/module/storage_preroll.py\u2020L108-L133\u3011 It records the user's current FPS choice, switches the camera to the maximum FPS supported by the sensor/mode and raises a \"pre-roll active\" flag so other systems (such as the rec command) leave it alone.\u3010F:src/module/storage_preroll.py\u2020L134-L170\u3011\u3010F:src/module/cinepi_controller.py\u2020L523-L542\u3011 Cinemate starts recording, waits until the REC flag is live, keeps rolling for the configured duration (two seconds by default) and then stops once all file buffers have flushed to disk.\u3010F:src/module/storage_preroll.py\u2020L134-L170\u3011 Finally, it restores the previous FPS, clears the activity flag and deletes any temporary clip directories created during the warm-up so the test footage never clutters your drive.\u3010F:src/module/storage_preroll.py\u2020L170-L208\u3011 Why it matters # Running a quick high-FPS burst before your first take helps avoid storage hiccups (for example, when an SSD controller is still negotiating link speed or establishing its allocation tables). Because Cinemate blocks normal rec requests while a pre-roll is active, you will always start your real recording on a fresh, warmed-up drive.\u3010F:src/module/storage_preroll.py\u2020L134-L208\u3011\u3010F:src/module/cinepi_controller.py\u2020L523-L542\u3011 Trigger it manually after swapping drives or when you have not recorded for a while to ensure peak performance.","title":"Storage pre-roll warm-up"},{"location":"storage-preroll/#storage-pre-roll-warm-up","text":"Cinemate includes an automatic \"storage pre-roll\" that records and discards a short clip to make sure new media can keep up before you roll on something important.\u3010F:src/module/storage_preroll.py\u2020L1-L57\u3011 The warm-up runs the recorder at full speed so SSDs spin up, controllers cache their write tables and the rest of the pipeline has a chance to stabilise.","title":"Storage pre-roll warm-up"},{"location":"storage-preroll/#when-the-pre-roll-runs","text":"On startup: after a brief settle delay, the helper checks whether the RAW volume is mounted and triggers a warm-up run if so.\u3010F:src/module/storage_preroll.py\u2020L58-L96\u3011 Whenever storage mounts: the SSD monitor emits an event that immediately schedules another pre-roll so freshly attached drives are exercised before you use them.\u3010F:src/module/storage_preroll.py\u2020L40-L92\u3011 On demand: you can type storage preroll in the Cinemate CLI to queue a run manually. The command is ignored while a pre-roll is already active so repeated presses do not stack up.\u3010F:src/module/cli_commands.py\u2020L64-L72\u3011\u3010F:src/module/storage_preroll.py\u2020L40-L92\u3011 The module keeps a lock so only one warm-up runs at a time and exposes the storage_preroll_active Redis key to let the UI show progress.\u3010F:src/module/storage_preroll.py\u2020L26-L74\u3011","title":"When the pre-roll runs"},{"location":"storage-preroll/#what-happens-during-a-run","text":"The helper aborts if no media is mounted or if a real recording is in progress; it will try again after the next trigger.\u3010F:src/module/storage_preroll.py\u2020L108-L133\u3011 It records the user's current FPS choice, switches the camera to the maximum FPS supported by the sensor/mode and raises a \"pre-roll active\" flag so other systems (such as the rec command) leave it alone.\u3010F:src/module/storage_preroll.py\u2020L134-L170\u3011\u3010F:src/module/cinepi_controller.py\u2020L523-L542\u3011 Cinemate starts recording, waits until the REC flag is live, keeps rolling for the configured duration (two seconds by default) and then stops once all file buffers have flushed to disk.\u3010F:src/module/storage_preroll.py\u2020L134-L170\u3011 Finally, it restores the previous FPS, clears the activity flag and deletes any temporary clip directories created during the warm-up so the test footage never clutters your drive.\u3010F:src/module/storage_preroll.py\u2020L170-L208\u3011","title":"What happens during a run"},{"location":"storage-preroll/#why-it-matters","text":"Running a quick high-FPS burst before your first take helps avoid storage hiccups (for example, when an SSD controller is still negotiating link speed or establishing its allocation tables). Because Cinemate blocks normal rec requests while a pre-roll is active, you will always start your real recording on a fresh, warmed-up drive.\u3010F:src/module/storage_preroll.py\u2020L134-L208\u3011\u3010F:src/module/cinepi_controller.py\u2020L523-L542\u3011 Trigger it manually after swapping drives or when you have not recorded for a while to ensure peak performance.","title":"Why it matters"},{"location":"system-services/","text":"System services # Cinemate uses three system services for its operation. cinemate-autostart.service # Responsible for autostart of Cinemate on boot. By default, it is turned off on the downloadable image file . Starting in v3.2 the service now waits for the camera sensor to come online before launching the UI. The helper script /usr/local/bin/camera-ready.sh polls cinepi-raw --list-cameras for up to 30 seconds and logs progress to the systemd journal so Cinemate does not start with a black screen if the IMX sensor is still initialising. Starting, stopping, enabling and disabling the service # Go to the Cinemate folder: cd cinemate make install # copy service file make enable # start on boot make start # launch now make stop # stop it make status # check status make disable # disable autostart make clean # remove the service The make install step also copies camera-ready.sh into /usr/local/bin/ with execute permissions so that the systemd unit can call it from ExecStartPre . To start Cinemate manually, anywhere in the cli, type cinemate . storage-automount.service # Storage-automount is a systemd service that watches for removable drives and mounts them automatically. The accompanying Python script reacts to udev events and the CFE-HAT eject button so drives can be attached or detached safely. It understands ext4 , ntfs and exfat filesystems. Partitions labelled RAW are mounted at /media/RAW ; any other label is mounted under /media/<LABEL> after sanitising the name. This applies to USB SSDs, NVMe drives and the CFE-HAT slot. Note On the image file, the storage-automount.service is activated by default. To manually install and enable the service: cd cinemate/services/storage-automount sudo make install sudo make enable You can stop or disable it later with: sudo make stop sudo make disable wifi-hotspot.service # Wifi-hotspot keeps a small access point running with the help of NetworkManager so you can always reach the web interface. The SSID and password are read from /home/pi/cinemate/src/settings.json under system.wifi_hotspot . Install and enable it with: cd cinemate/services/wifi-hotspot sudo make install sudo make enable As with storage-automount , you can stop or disable the hotspot with ` make stop make disable Note While evaluating, it might be practical to have the Pi connect to your local wifi for easy access ( sudo raspi-config ). Therefore, on the image file, the wifi-hotspot.service is not activated by default. Cinemate will still stream its web interface on the available netowrk. You can read more here","title":"System services"},{"location":"system-services/#system-services","text":"Cinemate uses three system services for its operation.","title":"System services"},{"location":"system-services/#cinemate-autostartservice","text":"Responsible for autostart of Cinemate on boot. By default, it is turned off on the downloadable image file . Starting in v3.2 the service now waits for the camera sensor to come online before launching the UI. The helper script /usr/local/bin/camera-ready.sh polls cinepi-raw --list-cameras for up to 30 seconds and logs progress to the systemd journal so Cinemate does not start with a black screen if the IMX sensor is still initialising.","title":"cinemate-autostart.service"},{"location":"system-services/#starting-stopping-enabling-and-disabling-the-service","text":"Go to the Cinemate folder: cd cinemate make install # copy service file make enable # start on boot make start # launch now make stop # stop it make status # check status make disable # disable autostart make clean # remove the service The make install step also copies camera-ready.sh into /usr/local/bin/ with execute permissions so that the systemd unit can call it from ExecStartPre . To start Cinemate manually, anywhere in the cli, type cinemate .","title":"Starting, stopping, enabling and disabling the service"},{"location":"system-services/#storage-automountservice","text":"Storage-automount is a systemd service that watches for removable drives and mounts them automatically. The accompanying Python script reacts to udev events and the CFE-HAT eject button so drives can be attached or detached safely. It understands ext4 , ntfs and exfat filesystems. Partitions labelled RAW are mounted at /media/RAW ; any other label is mounted under /media/<LABEL> after sanitising the name. This applies to USB SSDs, NVMe drives and the CFE-HAT slot. Note On the image file, the storage-automount.service is activated by default. To manually install and enable the service: cd cinemate/services/storage-automount sudo make install sudo make enable You can stop or disable it later with: sudo make stop sudo make disable","title":"storage-automount.service"},{"location":"system-services/#wifi-hotspotservice","text":"Wifi-hotspot keeps a small access point running with the help of NetworkManager so you can always reach the web interface. The SSID and password are read from /home/pi/cinemate/src/settings.json under system.wifi_hotspot . Install and enable it with: cd cinemate/services/wifi-hotspot sudo make install sudo make enable As with storage-automount , you can stop or disable the hotspot with ` make stop make disable Note While evaluating, it might be practical to have the Pi connect to your local wifi for easy access ( sudo raspi-config ). Therefore, on the image file, the wifi-hotspot.service is not activated by default. Cinemate will still stream its web interface on the available netowrk. You can read more here","title":"wifi-hotspot.service"},{"location":"todo/","text":"Todo # - simple_gui . py adaptive layout for non 1920 x1080 screens - 16 bit modes for imx585 - support for imx294 - overclocking of ISP - optional auto - exposure - hardware sync of sensor frame capture , perhaps via a pico - rendering mode , for creating proxy files in camera ( using https : //github.com/mrjulesfletcher/dng_to_video) - automatic detection of attached sensor and dynamic dtoverlay","title":"Todo"},{"location":"todo/#todo","text":"- simple_gui . py adaptive layout for non 1920 x1080 screens - 16 bit modes for imx585 - support for imx294 - overclocking of ISP - optional auto - exposure - hardware sync of sensor frame capture , perhaps via a pico - rendering mode , for creating proxy files in camera ( using https : //github.com/mrjulesfletcher/dng_to_video) - automatic detection of attached sensor and dynamic dtoverlay","title":"Todo"},{"location":"troubleshooting/","text":"","title":"Troubleshooting"},{"location":"web-gui/","text":"TBA","title":"Web gui"}]}