{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cinemate Docs # Welcome to the Cinemate project - an open-source boiler plate for building your own digital cinema camera using a Raspberry Pi 5. It combines a lightweight Python interface with the CinePi\u2011raw recorder by Csaba Nagy for capturing 12\u2011bit CinemaDNG footage. To begin, follow the steps in Quick start . Later chapters explain how to customise the system to tailor Cinemate to your needs. For sharing your build with others, inspiration and discussion, make sure to join the CinePi Discord . Download this documentation in pdf format for easy offline reference.","title":"Home"},{"location":"#cinemate-docs","text":"Welcome to the Cinemate project - an open-source boiler plate for building your own digital cinema camera using a Raspberry Pi 5. It combines a lightweight Python interface with the CinePi\u2011raw recorder by Csaba Nagy for capturing 12\u2011bit CinemaDNG footage. To begin, follow the steps in Quick start . Later chapters explain how to customise the system to tailor Cinemate to your needs. For sharing your build with others, inspiration and discussion, make sure to join the CinePi Discord . Download this documentation in pdf format for easy offline reference.","title":"Cinemate Docs"},{"location":"acknowledgments/","text":"Acknowledgements # The Cinemate stack is built on top of several open-source projects. Special thanks to all authors! CinePi-raw \u2013 Csaba Nagy IMX585 and IMX283 drivers \u2013 Will Whang libcamera \u2013 Ideas on board cpp-mjpeg-streamer \u2013 Nadjieb Mohammadi lgpio \u2013 Joan Also thanks to Simon at Altcinecam for support and assistance! Get your sensors and CFE Hats here: https://www.tindie.com/stores/will123321/","title":"Acknowledgements"},{"location":"acknowledgments/#acknowledgements","text":"The Cinemate stack is built on top of several open-source projects. Special thanks to all authors! CinePi-raw \u2013 Csaba Nagy IMX585 and IMX283 drivers \u2013 Will Whang libcamera \u2013 Ideas on board cpp-mjpeg-streamer \u2013 Nadjieb Mohammadi lgpio \u2013 Joan Also thanks to Simon at Altcinecam for support and assistance! Get your sensors and CFE Hats here: https://www.tindie.com/stores/will123321/","title":"Acknowledgements"},{"location":"audio-recording/","text":"Audio recording (experimental) # Cinemate records audio alongside the image sequence. Support is currently limited to a few USB microphones with hard coded configurations: - R\u00d8DE VideoMic NTG \u2013 recorded in stereo at 24\u2011bit/48 kHz. - USB PnP microphones \u2013 recorded in mono at 16\u2011bit/48 kHz. Audio is written as .wav files into the same folder as the .dng frames. The implementation is still experimental and audio/video synchronization needs further investigation. .asoundrc Setup # For dsnoop support, create a ~/.asoundrc in home directory: nano ~/.asoundrc Paste this into the file: pcm.dsnoop_24bit { type dsnoop ipc_key 2048 slave { pcm \"hw:Device,0\" channels 2 rate 48000 format S24_3LE period_size 1024 buffer_size 4096 } } pcm.dsnoop_16bit { type dsnoop ipc_key 2049 slave { pcm \"hw:Device,0\" channels 1 rate 48000 format S16_LE period_size 1024 buffer_size 4096 } } pcm.mic_24bit { type plug slave.pcm \"dsnoop_24bit\" } pcm.mic_16bit { type plug slave.pcm \"dsnoop_16bit\" } Exit nano editor using ctrl+x.","title":"Audio recording"},{"location":"audio-recording/#audio-recording-experimental","text":"Cinemate records audio alongside the image sequence. Support is currently limited to a few USB microphones with hard coded configurations: - R\u00d8DE VideoMic NTG \u2013 recorded in stereo at 24\u2011bit/48 kHz. - USB PnP microphones \u2013 recorded in mono at 16\u2011bit/48 kHz. Audio is written as .wav files into the same folder as the .dng frames. The implementation is still experimental and audio/video synchronization needs further investigation.","title":"Audio recording (experimental)"},{"location":"audio-recording/#asoundrc-setup","text":"For dsnoop support, create a ~/.asoundrc in home directory: nano ~/.asoundrc Paste this into the file: pcm.dsnoop_24bit { type dsnoop ipc_key 2048 slave { pcm \"hw:Device,0\" channels 2 rate 48000 format S24_3LE period_size 1024 buffer_size 4096 } } pcm.dsnoop_16bit { type dsnoop ipc_key 2049 slave { pcm \"hw:Device,0\" channels 1 rate 48000 format S16_LE period_size 1024 buffer_size 4096 } } pcm.mic_24bit { type plug slave.pcm \"dsnoop_24bit\" } pcm.mic_16bit { type plug slave.pcm \"dsnoop_16bit\" } Exit nano editor using ctrl+x.","title":".asoundrc Setup"},{"location":"backing-up-sd-card/","text":"Backing up the SD card # Create a compressed image: sudo dd if = /dev/mmcblk0 bs = 4M conv = sparse,noerror status = progress | gzip -c > /media/RAW/cinemate_ $( date + \"%Y%m%d_%H%M%S\" ) .img.gz Or use PiShrink for a smaller file: sudo bash -Eeuo pipefail -c ' # Timestamp like 2025-07-19_19-38-33 ts=$(date +%F_%H-%M-%S) # Paths on /media/RAW raw=\"/media/RAW/Cinemate_${ts}.img\" # working image final=\"/media/RAW/cinemate_${ts}.img.xz\" # desired end-result # 1 \u2500 Image the SD-card (pads bad blocks, keeps sparsity) dd if=/dev/mmcblk0 of=\"$raw\" \\ bs=4M conv=noerror,sync,sparse status=progress # 2 \u2500 Shrink + parallel-xz compress **in place** /usr/local/bin/pishrink.sh -s -v -Z -a \"$raw\" # 3 \u2500 Rename the freshly-made .xz to the lowercase style you want mv \"${raw}.xz\" \"$final\" # 4 \u2500 Remove the now-unused raw image rm -f \"$raw\" '","title":"Backing up the SD card"},{"location":"backing-up-sd-card/#backing-up-the-sd-card","text":"Create a compressed image: sudo dd if = /dev/mmcblk0 bs = 4M conv = sparse,noerror status = progress | gzip -c > /media/RAW/cinemate_ $( date + \"%Y%m%d_%H%M%S\" ) .img.gz Or use PiShrink for a smaller file: sudo bash -Eeuo pipefail -c ' # Timestamp like 2025-07-19_19-38-33 ts=$(date +%F_%H-%M-%S) # Paths on /media/RAW raw=\"/media/RAW/Cinemate_${ts}.img\" # working image final=\"/media/RAW/cinemate_${ts}.img.xz\" # desired end-result # 1 \u2500 Image the SD-card (pads bad blocks, keeps sparsity) dd if=/dev/mmcblk0 of=\"$raw\" \\ bs=4M conv=noerror,sync,sparse status=progress # 2 \u2500 Shrink + parallel-xz compress **in place** /usr/local/bin/pishrink.sh -s -v -Z -a \"$raw\" # 3 \u2500 Rename the freshly-made .xz to the lowercase style you want mv \"${raw}.xz\" \"$final\" # 4 \u2500 Remove the now-unused raw image rm -f \"$raw\" '","title":"Backing up the SD card"},{"location":"bare-bones-build/","text":"","title":"Bare bones build"},{"location":"brick/","text":"TBA","title":"Box build"},{"location":"cinepi-multi/","text":"How Cinemate launches cinepi-raw # cinemate/src/module/cinepi_multi.py starts one cinepi-raw process per connected camera. It takes user settings from sensor_detect.py and settings.json to influence the command-line flags passed to cinepi-raw . Here it how it works: Detecting Cameras # When CineMate starts, CinePiManager runs cinepi-raw --list-cameras . Each line of output describes a connected sensor. The manager parses this output and stores basic information about every camera: index \u2013 numeric index passed to --camera model \u2013 sensor model name (e.g. imx477 ) mono \u2013 whether the camera is monochrome This information is kept in the CameraInfo class and written to Redis under the cam_info keys so that other modules know which sensors are present. Loading Resolution Data # cinepi_multi.py relies on sensor_detect.py to look up valid resolutions and frame rates for each sensor. The mapping lives in src/module/sensor_detect.py and is organised like this: sensor_resolutions = { 'imx477' : { 0 : { 'width' : 2028 , 'height' : 1080 , 'bit_depth' : 12 , 'fps_max' : 50 }, 1 : { 'width' : 2028 , 'height' : 1520 , 'bit_depth' : 12 , 'fps_max' : 40 }, # ... }, 'imx585_mono' : { 0 : { 'width' : 1928 , 'height' : 1090 , 'bit_depth' : 12 , 'fps_max' : 87 }, } } If you add support for a new sensor or want to tweak maximum frame rates, modify this dictionary. cinepi_multi calls get_resolution_info() to fetch the entry for the detected model and sensor mode (stored in Redis as sensor_mode ). Note that there is a diference between driver sensor modes and Cinemate sensor modes . Driver sensor modes are presented with the terminal command cinepi-raw --list-cameras and then used by the list in src/module/sensor_detect.py to match the Cinemate / user sensor mode with the actual one. This is a bit clumsy so future updates aim at having sensor modes loaded dynamically. What firther complicate things is that libcameras sensor numbering dows not match the physical port numbering, which Cinemate uses for its mapping of preview to HDMI ports. So this need to be sorted out somehow. :) Building the cinepi-raw Command # For each detected camera the manager creates a CinePiProcess . The _build_args() method constructs a list of command-line flags for cinepi-raw : Resolution flags \u2013 --mode , --width , --height are taken from sensor_detect . Preview size \u2013 low\u2011resolution dimensions are calculated so that the preview fits inside the HDMI framebuffer. The values are stored in Redis as lores_width and lores_height . Geometry \u2013 the geometry section in settings.json allows you to rotate or flip each camera. These settings translate to --rotation , --hflip and --vflip flags. Output mapping \u2013 the output section chooses which HDMI connector each camera uses. The primary camera shows a preview window unless --nopreview is specified. Synchronization \u2013 if more than one camera is present, the first one is started with --sync server and the rest with --sync client so that frame capture is aligned. Here is a simplified example of the resulting command: cinepi-raw --camera 0 --mode 2028 :1080:12:U \\ --width 2028 --height 1080 \\ --lores-width 1280 --lores-height 720 \\ --hdmi-port 0 --rotation 0 --hflip 0 --vflip 0 \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json Secondary cameras would receive --nopreview and a different --hdmi-port based on your settings. cinepi_multi.py lives in src/module/ . If you want to change how arguments are built, look inside the _build_args() method. The rest of the file deals with process management, log forwarding and readiness checks. Waiting for Cameras to Become Ready # Each cinepi-raw instance prints Encoder configured when it has finished initialising. cinepi_multi watches the output and sets a Redis key like cinepi_ready_cam0 . The manager waits until every launched camera reports ready before CineMate proceeds. This ensures that the very first REC command is seen by all sensors simultaneously. Customising Behaviour # sensor_detect.py \u2013 add new entries or adjust values under sensor_resolutions if you connect a sensor with different modes. The dictionary format mirrors the command-line --mode flag. settings.json \u2013 update the geometry and output sections for per\u2011camera rotation, flipping and HDMI mapping. These settings are read at startup and directly influence the arguments passed to cinepi-raw .","title":"How Cinemate launches cinepi-raw"},{"location":"cinepi-multi/#how-cinemate-launches-cinepi-raw","text":"cinemate/src/module/cinepi_multi.py starts one cinepi-raw process per connected camera. It takes user settings from sensor_detect.py and settings.json to influence the command-line flags passed to cinepi-raw . Here it how it works:","title":"How Cinemate launches cinepi-raw"},{"location":"cinepi-multi/#detecting-cameras","text":"When CineMate starts, CinePiManager runs cinepi-raw --list-cameras . Each line of output describes a connected sensor. The manager parses this output and stores basic information about every camera: index \u2013 numeric index passed to --camera model \u2013 sensor model name (e.g. imx477 ) mono \u2013 whether the camera is monochrome This information is kept in the CameraInfo class and written to Redis under the cam_info keys so that other modules know which sensors are present.","title":"Detecting Cameras"},{"location":"cinepi-multi/#loading-resolution-data","text":"cinepi_multi.py relies on sensor_detect.py to look up valid resolutions and frame rates for each sensor. The mapping lives in src/module/sensor_detect.py and is organised like this: sensor_resolutions = { 'imx477' : { 0 : { 'width' : 2028 , 'height' : 1080 , 'bit_depth' : 12 , 'fps_max' : 50 }, 1 : { 'width' : 2028 , 'height' : 1520 , 'bit_depth' : 12 , 'fps_max' : 40 }, # ... }, 'imx585_mono' : { 0 : { 'width' : 1928 , 'height' : 1090 , 'bit_depth' : 12 , 'fps_max' : 87 }, } } If you add support for a new sensor or want to tweak maximum frame rates, modify this dictionary. cinepi_multi calls get_resolution_info() to fetch the entry for the detected model and sensor mode (stored in Redis as sensor_mode ). Note that there is a diference between driver sensor modes and Cinemate sensor modes . Driver sensor modes are presented with the terminal command cinepi-raw --list-cameras and then used by the list in src/module/sensor_detect.py to match the Cinemate / user sensor mode with the actual one. This is a bit clumsy so future updates aim at having sensor modes loaded dynamically. What firther complicate things is that libcameras sensor numbering dows not match the physical port numbering, which Cinemate uses for its mapping of preview to HDMI ports. So this need to be sorted out somehow. :)","title":"Loading Resolution Data"},{"location":"cinepi-multi/#building-the-cinepi-raw-command","text":"For each detected camera the manager creates a CinePiProcess . The _build_args() method constructs a list of command-line flags for cinepi-raw : Resolution flags \u2013 --mode , --width , --height are taken from sensor_detect . Preview size \u2013 low\u2011resolution dimensions are calculated so that the preview fits inside the HDMI framebuffer. The values are stored in Redis as lores_width and lores_height . Geometry \u2013 the geometry section in settings.json allows you to rotate or flip each camera. These settings translate to --rotation , --hflip and --vflip flags. Output mapping \u2013 the output section chooses which HDMI connector each camera uses. The primary camera shows a preview window unless --nopreview is specified. Synchronization \u2013 if more than one camera is present, the first one is started with --sync server and the rest with --sync client so that frame capture is aligned. Here is a simplified example of the resulting command: cinepi-raw --camera 0 --mode 2028 :1080:12:U \\ --width 2028 --height 1080 \\ --lores-width 1280 --lores-height 720 \\ --hdmi-port 0 --rotation 0 --hflip 0 --vflip 0 \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json Secondary cameras would receive --nopreview and a different --hdmi-port based on your settings. cinepi_multi.py lives in src/module/ . If you want to change how arguments are built, look inside the _build_args() method. The rest of the file deals with process management, log forwarding and readiness checks.","title":"Building the cinepi-raw Command"},{"location":"cinepi-multi/#waiting-for-cameras-to-become-ready","text":"Each cinepi-raw instance prints Encoder configured when it has finished initialising. cinepi_multi watches the output and sets a Redis key like cinepi_ready_cam0 . The manager waits until every launched camera reports ready before CineMate proceeds. This ensures that the very first REC command is seen by all sensors simultaneously.","title":"Waiting for Cameras to Become Ready"},{"location":"cinepi-multi/#customising-behaviour","text":"sensor_detect.py \u2013 add new entries or adjust values under sensor_resolutions if you connect a sensor with different modes. The dictionary format mirrors the command-line --mode flag. settings.json \u2013 update the geometry and output sections for per\u2011camera rotation, flipping and HDMI mapping. These settings are read at startup and directly influence the arguments passed to cinepi-raw .","title":"Customising Behaviour"},{"location":"cli-commands/","text":"Commands reference # Cinemate doesn\u2019t use a real shell parser. Instead, a background thread reads simple text commands from SSH or the serial port and calls the corresponding controller methods. Available Commands # Command Input type Example Function rec / stop none rec Toggle recording on or off set iso <value> int set iso 800 Set ISO to nearest allowed step inc iso / dec iso none inc iso Step ISO up or down set shutter a <angle> float set shutter a 180 Set actual shutter angle (snaps unless free/sync) inc shutter a / dec shutter a none inc shutter a Cycle through shutter angles set shutter a nom <angle> float set shutter a nom 180 Set nominal shutter angle for motion blur inc shutter a nom / dec shutter a nom none inc shutter a nom Step the nominal shutter angle set fps <value> float set fps 24 Change frame rate (snaps unless free) inc fps / dec fps none inc fps Step through FPS list set wb [<Kelvin>] int or none set wb 5600 Set white balance or cycle presets inc wb / dec wb none inc wb Cycle white balance steps set resolution [<mode>] int or none set resolution 2 Apply or cycle sensor mode set anamorphic factor [<float>] float or none set anamorphic factor 1.33 Set or toggle anamorphic stretch set zoom [<float>] float or none set zoom 2 Change digital zoom; omit to cycle inc zoom / dec zoom none inc zoom Step preview zoom factor mount / unmount none mount Mount or unmount external storage toggle mount none toggle mount Mount if not mounted, otherwise unmount time none time Show system and RTC time set rtc time none set rtc time Copy system time to the RTC space none space Report remaining SSD space get none get Print all current settings set shutter a sync [0/1] 0/1 or none set shutter a sync 1 Enable exposure sync mode set iso lock [0/1] 0/1 or none set iso lock Lock or unlock ISO setting set shutter a nom lock [0/1] 0/1 or none set shutter a nom lock Lock or unlock nominal shutter set shutter a nom fps lock [0/1] 0/1 or none set shutter a nom fps lock 1 Lock nominal shutter and FPS together set fps lock [0/1] 0/1 or none set fps lock 1 Lock or unlock the frame rate set all lock [0/1] 0/1 or none set all lock 0 Toggle all exposure locks at once set fps double [0/1] 0/1 or none set fps double Instant or toggled 2\u00d7 FPS mode reboot / shutdown none reboot Safely reboot or halt the Pi restart camera none restart camera Restart the libcamera pipeline restart cinemate none restart cinemate Restart the Cinemate process set iso free [0/1] 0/1 or none set iso free 1 Allow any ISO instead of presets set shutter a free [0/1] 0/1 or none set shutter a free 0 Allow any shutter angle set fps free [0/1] 0/1 or none set fps free 1 Allow any FPS set wb free [0/1] 0/1 or none set wb free Allow any white balance set filter <0/1> 0/1 set filter 1 Toggle IR-cut filter (IMX585) Commands without an explicit argument will toggle the current state when possible (e.g. set fps lock flips the lock; set fps lock 1 forces it on).","title":"Commands reference"},{"location":"cli-commands/#commands-reference","text":"Cinemate doesn\u2019t use a real shell parser. Instead, a background thread reads simple text commands from SSH or the serial port and calls the corresponding controller methods.","title":"Commands reference"},{"location":"cli-commands/#available-commands","text":"Command Input type Example Function rec / stop none rec Toggle recording on or off set iso <value> int set iso 800 Set ISO to nearest allowed step inc iso / dec iso none inc iso Step ISO up or down set shutter a <angle> float set shutter a 180 Set actual shutter angle (snaps unless free/sync) inc shutter a / dec shutter a none inc shutter a Cycle through shutter angles set shutter a nom <angle> float set shutter a nom 180 Set nominal shutter angle for motion blur inc shutter a nom / dec shutter a nom none inc shutter a nom Step the nominal shutter angle set fps <value> float set fps 24 Change frame rate (snaps unless free) inc fps / dec fps none inc fps Step through FPS list set wb [<Kelvin>] int or none set wb 5600 Set white balance or cycle presets inc wb / dec wb none inc wb Cycle white balance steps set resolution [<mode>] int or none set resolution 2 Apply or cycle sensor mode set anamorphic factor [<float>] float or none set anamorphic factor 1.33 Set or toggle anamorphic stretch set zoom [<float>] float or none set zoom 2 Change digital zoom; omit to cycle inc zoom / dec zoom none inc zoom Step preview zoom factor mount / unmount none mount Mount or unmount external storage toggle mount none toggle mount Mount if not mounted, otherwise unmount time none time Show system and RTC time set rtc time none set rtc time Copy system time to the RTC space none space Report remaining SSD space get none get Print all current settings set shutter a sync [0/1] 0/1 or none set shutter a sync 1 Enable exposure sync mode set iso lock [0/1] 0/1 or none set iso lock Lock or unlock ISO setting set shutter a nom lock [0/1] 0/1 or none set shutter a nom lock Lock or unlock nominal shutter set shutter a nom fps lock [0/1] 0/1 or none set shutter a nom fps lock 1 Lock nominal shutter and FPS together set fps lock [0/1] 0/1 or none set fps lock 1 Lock or unlock the frame rate set all lock [0/1] 0/1 or none set all lock 0 Toggle all exposure locks at once set fps double [0/1] 0/1 or none set fps double Instant or toggled 2\u00d7 FPS mode reboot / shutdown none reboot Safely reboot or halt the Pi restart camera none restart camera Restart the libcamera pipeline restart cinemate none restart cinemate Restart the Cinemate process set iso free [0/1] 0/1 or none set iso free 1 Allow any ISO instead of presets set shutter a free [0/1] 0/1 or none set shutter a free 0 Allow any shutter angle set fps free [0/1] 0/1 or none set fps free 1 Allow any FPS set wb free [0/1] 0/1 or none set wb free Allow any white balance set filter <0/1> 0/1 set filter 1 Toggle IR-cut filter (IMX585) Commands without an explicit argument will toggle the current state when possible (e.g. set fps lock flips the lock; set fps lock 1 forces it on).","title":"Available Commands"},{"location":"cli-user-guide/","text":"CLI user guide # Here is how you can operate CinePi-raw from the command line. Checking available options # Before running the program you can view all command\u2011line flags with: cinepi-raw -h This prints a long list of options supported by the application. It includes the standard parameters from rpicam-apps (such as resolution and exposure settings) plus additional flags specific to the Cinemate. Camera modes # CinePi-raw uses Libcamera to talk to your Raspberry Pi camera module. Each sensor supports one or more modes , which define the resolution and bit depth of the RAW images that the sensor can produce. A mode is written as: --mode 2028:1080:12:U width and height select the active pixel area of the sensor. bit-depth is usually 12 or 16 bits per pixel. packing can be P for packed or U for unpacked data. The mode must match the sensor you are using. For example, an IMX477 camera can run at 4056:3040:12 (full sensor) or at smaller cropped resolutions. When specifying a mode you typically also set the output --width and --height which control the size of the image written to disk. These can be equal to the mode values or smaller when scaling is applied. Low\u2011resolution (lores) stream # --lores-width 1280 --lores-height 720 CinePi-raw can produce a secondary low\u2011resolution stream alongside the full\u2011resolution RAW frames. Preview window # By default the program opens an HDMI preview so you can see what the camera captures. The size and position of this window are controlled with: -p 0,30,1920,1020 This positions the preview 30 pixels from the top of the screen with a 1920\u00d71020 window. Tuning files # --tuning-file /home/pi/cinemate/resources/tuning_files/imx477.json Describes the camera\u2019s colour and lens characteristics. Point to a file supplied with Libcamera (for example imx477.json for the HQ camera) Post processing # --post-process-file /home/pi/post-processing.json For cinepi-raw, this file defines the port used by cpp-mjpeg-streamer (default cinepi.local:8000) If you have more than one camera connected to the Pi, and activated in boot/firmware/config.txt , the camera commected to physical cam0 will use /home/pi/post-processing0.json and the camera connected to cam1 will use /home/pi/post-processing1.json Cinemate\u2011specific flags # The CineMate fork introduces several extra options: Flag Argument Description --cam-port cam0 | cam1 Select which CSI camera port to use. --hdmi-port 0 | 1 | -1 Choose the HDMI connector for the preview ( 0 = HDMI-0, 1 = HDMI-1, -1 = auto-detect). --same-hdmi (none) Force both capture and controller GUI to share the same HDMI output. --keep16 true | false Save full 16-bit DNGs instead of 12-bit packed files. At this moment though, Cinemate is 12bit only. The flag is for future updates of the IMX585 16bit clear HDR modes. Example commands # Below are sample commands for different sensors and modes. IMX477 (12\u2011bit, full width) # cinepi-raw --mode 4056 :2160:12 --width 4056 --height 2160 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json \\ IMX585 (12\u2011bit unpacked) # cinepi-raw --mode 1928 :1090:12:U --width 1928 --height 1090 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ Now, with an SSH shell running redis-cli you should be able to capture RAW footage from the command line! redis-cli > set is_recording 1 > publish cp_controls is_recording","title":"Using the CLI"},{"location":"cli-user-guide/#cli-user-guide","text":"Here is how you can operate CinePi-raw from the command line.","title":"CLI user guide"},{"location":"cli-user-guide/#checking-available-options","text":"Before running the program you can view all command\u2011line flags with: cinepi-raw -h This prints a long list of options supported by the application. It includes the standard parameters from rpicam-apps (such as resolution and exposure settings) plus additional flags specific to the Cinemate.","title":"Checking available options"},{"location":"cli-user-guide/#camera-modes","text":"CinePi-raw uses Libcamera to talk to your Raspberry Pi camera module. Each sensor supports one or more modes , which define the resolution and bit depth of the RAW images that the sensor can produce. A mode is written as: --mode 2028:1080:12:U width and height select the active pixel area of the sensor. bit-depth is usually 12 or 16 bits per pixel. packing can be P for packed or U for unpacked data. The mode must match the sensor you are using. For example, an IMX477 camera can run at 4056:3040:12 (full sensor) or at smaller cropped resolutions. When specifying a mode you typically also set the output --width and --height which control the size of the image written to disk. These can be equal to the mode values or smaller when scaling is applied.","title":"Camera modes"},{"location":"cli-user-guide/#lowresolution-lores-stream","text":"--lores-width 1280 --lores-height 720 CinePi-raw can produce a secondary low\u2011resolution stream alongside the full\u2011resolution RAW frames.","title":"Low\u2011resolution (lores) stream"},{"location":"cli-user-guide/#preview-window","text":"By default the program opens an HDMI preview so you can see what the camera captures. The size and position of this window are controlled with: -p 0,30,1920,1020 This positions the preview 30 pixels from the top of the screen with a 1920\u00d71020 window.","title":"Preview window"},{"location":"cli-user-guide/#tuning-files","text":"--tuning-file /home/pi/cinemate/resources/tuning_files/imx477.json Describes the camera\u2019s colour and lens characteristics. Point to a file supplied with Libcamera (for example imx477.json for the HQ camera)","title":"Tuning files"},{"location":"cli-user-guide/#post-processing","text":"--post-process-file /home/pi/post-processing.json For cinepi-raw, this file defines the port used by cpp-mjpeg-streamer (default cinepi.local:8000) If you have more than one camera connected to the Pi, and activated in boot/firmware/config.txt , the camera commected to physical cam0 will use /home/pi/post-processing0.json and the camera connected to cam1 will use /home/pi/post-processing1.json","title":"Post processing"},{"location":"cli-user-guide/#cinematespecific-flags","text":"The CineMate fork introduces several extra options: Flag Argument Description --cam-port cam0 | cam1 Select which CSI camera port to use. --hdmi-port 0 | 1 | -1 Choose the HDMI connector for the preview ( 0 = HDMI-0, 1 = HDMI-1, -1 = auto-detect). --same-hdmi (none) Force both capture and controller GUI to share the same HDMI output. --keep16 true | false Save full 16-bit DNGs instead of 12-bit packed files. At this moment though, Cinemate is 12bit only. The flag is for future updates of the IMX585 16bit clear HDR modes.","title":"Cinemate\u2011specific flags"},{"location":"cli-user-guide/#example-commands","text":"Below are sample commands for different sensors and modes.","title":"Example commands"},{"location":"cli-user-guide/#imx477-12bit-full-width","text":"cinepi-raw --mode 4056 :2160:12 --width 4056 --height 2160 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx477.json \\","title":"IMX477 (12\u2011bit, full width)"},{"location":"cli-user-guide/#imx585-12bit-unpacked","text":"cinepi-raw --mode 1928 :1090:12:U --width 1928 --height 1090 \\ --lores-width 1280 --lores-height 720 \\ -p 0 ,30,1920,1020 \\ --post-process-file /home/pi/post-processing.json \\ --tuning-file /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ Now, with an SSH shell running redis-cli you should be able to capture RAW footage from the command line! redis-cli > set is_recording 1 > publish cp_controls is_recording","title":"IMX585 (12\u2011bit unpacked)"},{"location":"compiling-cinepi-raw/","text":"Recompiling cinepi-raw # Compiling cinepi-raw For easy later rebuilding and installation of cinepi-raw you can create the file compile-raw.sh. nano compile-raw.sh Paste this into the file sudo meson install -C build Exit by pressing Ctrl+C Make it exectutable: sudo chmod +x compile-raw.sh Now, from the same folder, to build and install cinepi-raw: ./compile-raw.sh","title":"Recompiling cinepi-raw"},{"location":"compiling-cinepi-raw/#recompiling-cinepi-raw","text":"Compiling cinepi-raw For easy later rebuilding and installation of cinepi-raw you can create the file compile-raw.sh. nano compile-raw.sh Paste this into the file sudo meson install -C build Exit by pressing Ctrl+C Make it exectutable: sudo chmod +x compile-raw.sh Now, from the same folder, to build and install cinepi-raw: ./compile-raw.sh","title":"Recompiling cinepi-raw"},{"location":"config-txt/","text":"Modifying config.txt # Adjusting config.txt for different sensors: # sudo nano /boot/firmware/config.txt Uncomment the section for the sensor being used, and make sure to comment out the others. Reboot the Pi for changes to take effect. Exit the editor by pressing Ctrl+C","title":"Modifying config.txt"},{"location":"config-txt/#modifying-configtxt","text":"","title":"Modifying config.txt"},{"location":"config-txt/#adjusting-configtxt-for-different-sensors","text":"sudo nano /boot/firmware/config.txt Uncomment the section for the sensor being used, and make sure to comment out the others. Reboot the Pi for changes to take effect. Exit the editor by pressing Ctrl+C","title":"Adjusting config.txt for different sensors:"},{"location":"contributing/","text":"","title":"Contributing to the project"},{"location":"contributors/","text":"","title":"Contributors"},{"location":"controller-methods/","text":"CinePi Controller Methods # CineMate exposes most of its runtime features through the CinePiController class in src/module/cinepi_controller.py . Buttons, the pseudo\u2011CLI and the web UI all call these methods. Below is an overview of the most useful ones and what they do. Recording # rec() \u2013 Toggle recording on or off depending on the current state. start_recording() \u2013 Begin recording if storage is mounted and space is available. stop_recording() \u2013 Stop the current recording. Exposure settings # These methods adjust ISO, shutter angle and frame rate. Increment/decrement helpers step through the arrays defined in settings.json unless free mode is active. set_iso(value) \u2013 Set ISO to a specific value. inc_iso() / dec_iso() \u2013 Step ISO up or down. set_shutter_a(value) \u2013 Set the actual shutter angle. In normal mode the value snaps to the nearest valid angle. inc_shutter_a() / dec_shutter_a() \u2013 Cycle through shutter angles. set_shutter_a_nom(value) \u2013 Set the nominal shutter angle used for motion\u2011blur calculations. inc_shutter_a_nom() / dec_shutter_a_nom() \u2013 Step the nominal shutter angle. set_fps(value) \u2013 Apply a new frame rate while respecting locks and sync mode. inc_fps() / dec_fps() \u2013 Step through the configured FPS list. White balance # set_wb(kelvin=None, direction='next') \u2013 Set white balance to a specific Kelvin temperature or cycle through presets if no value is given. inc_wb() / dec_wb() \u2013 Move to the next or previous white balance preset. Resolution and preview # set_resolution(value=None) \u2013 Switch sensor mode. Passing None cycles through the available modes. set_anamorphic_factor(value=None) \u2013 Change the preview\u2019s anamorphic stretch. Omit the value to toggle between presets. set_zoom(value=None, direction=\"next\") \u2013 Adjust the digital zoom factor. Without a value it steps through preview.zoom_steps . inc_zoom() / dec_zoom() \u2013 Convenience wrappers around set_zoom() . Storage control # mount() / unmount() \u2013 Mount or unmount the external drive. toggle_mount() \u2013 Convenience method that mounts when no drive is present and unmounts otherwise. System information # print_settings() \u2013 Log all current Redis parameters. ssd_monitor.space_left() \u2013 Report remaining disk space (used by the space CLI command). reboot() \u2013 Safely reboot the Pi. safe_shutdown() \u2013 Shut the Pi down cleanly. restart_cinemate() \u2013 Restart the Cinemate Python process without rebooting. Locks and sync modes # These helpers prevent accidental changes or keep shutter speed in sync with FPS: set_shutter_a_sync_mode(value=None) \u2013 Enable exposure\u2011sync mode (1) or normal mode (0). Omitting the value toggles the state. set_iso_lock(value=None) \u2013 Toggle or explicitly set the ISO lock. set_shutter_a_nom_lock(value=None) \u2013 Lock or unlock the nominal shutter angle. set_shu_fps_lock(value=None) \u2013 Lock both shutter angle and FPS together. set_fps_lock(value=None) \u2013 Lock or unlock the frame rate. set_all_lock(value=None) \u2013 Toggle all three locks at once. set_fps_double(value=None) \u2013 Temporarily double the frame rate. Omit the value to toggle. Free\u2011mode toggles # When free mode is enabled, the preset arrays from settings.json are ignored and you can dial any value supported by the sensor. set_iso_free(value=None) set_shutter_a_free(value=None) set_fps_free(value=None) set_wb_free(value=None) Sensor\u2011specific tools # set_filter(value=None) \u2013 Enable or disable the StarlightEye IR cut filter (IMX585 sensors only).","title":"CinePi Controller Methods"},{"location":"controller-methods/#cinepi-controller-methods","text":"CineMate exposes most of its runtime features through the CinePiController class in src/module/cinepi_controller.py . Buttons, the pseudo\u2011CLI and the web UI all call these methods. Below is an overview of the most useful ones and what they do.","title":"CinePi Controller Methods"},{"location":"controller-methods/#recording","text":"rec() \u2013 Toggle recording on or off depending on the current state. start_recording() \u2013 Begin recording if storage is mounted and space is available. stop_recording() \u2013 Stop the current recording.","title":"Recording"},{"location":"controller-methods/#exposure-settings","text":"These methods adjust ISO, shutter angle and frame rate. Increment/decrement helpers step through the arrays defined in settings.json unless free mode is active. set_iso(value) \u2013 Set ISO to a specific value. inc_iso() / dec_iso() \u2013 Step ISO up or down. set_shutter_a(value) \u2013 Set the actual shutter angle. In normal mode the value snaps to the nearest valid angle. inc_shutter_a() / dec_shutter_a() \u2013 Cycle through shutter angles. set_shutter_a_nom(value) \u2013 Set the nominal shutter angle used for motion\u2011blur calculations. inc_shutter_a_nom() / dec_shutter_a_nom() \u2013 Step the nominal shutter angle. set_fps(value) \u2013 Apply a new frame rate while respecting locks and sync mode. inc_fps() / dec_fps() \u2013 Step through the configured FPS list.","title":"Exposure settings"},{"location":"controller-methods/#white-balance","text":"set_wb(kelvin=None, direction='next') \u2013 Set white balance to a specific Kelvin temperature or cycle through presets if no value is given. inc_wb() / dec_wb() \u2013 Move to the next or previous white balance preset.","title":"White balance"},{"location":"controller-methods/#resolution-and-preview","text":"set_resolution(value=None) \u2013 Switch sensor mode. Passing None cycles through the available modes. set_anamorphic_factor(value=None) \u2013 Change the preview\u2019s anamorphic stretch. Omit the value to toggle between presets. set_zoom(value=None, direction=\"next\") \u2013 Adjust the digital zoom factor. Without a value it steps through preview.zoom_steps . inc_zoom() / dec_zoom() \u2013 Convenience wrappers around set_zoom() .","title":"Resolution and preview"},{"location":"controller-methods/#storage-control","text":"mount() / unmount() \u2013 Mount or unmount the external drive. toggle_mount() \u2013 Convenience method that mounts when no drive is present and unmounts otherwise.","title":"Storage control"},{"location":"controller-methods/#system-information","text":"print_settings() \u2013 Log all current Redis parameters. ssd_monitor.space_left() \u2013 Report remaining disk space (used by the space CLI command). reboot() \u2013 Safely reboot the Pi. safe_shutdown() \u2013 Shut the Pi down cleanly. restart_cinemate() \u2013 Restart the Cinemate Python process without rebooting.","title":"System information"},{"location":"controller-methods/#locks-and-sync-modes","text":"These helpers prevent accidental changes or keep shutter speed in sync with FPS: set_shutter_a_sync_mode(value=None) \u2013 Enable exposure\u2011sync mode (1) or normal mode (0). Omitting the value toggles the state. set_iso_lock(value=None) \u2013 Toggle or explicitly set the ISO lock. set_shutter_a_nom_lock(value=None) \u2013 Lock or unlock the nominal shutter angle. set_shu_fps_lock(value=None) \u2013 Lock both shutter angle and FPS together. set_fps_lock(value=None) \u2013 Lock or unlock the frame rate. set_all_lock(value=None) \u2013 Toggle all three locks at once. set_fps_double(value=None) \u2013 Temporarily double the frame rate. Omit the value to toggle.","title":"Locks and sync modes"},{"location":"controller-methods/#freemode-toggles","text":"When free mode is enabled, the preset arrays from settings.json are ignored and you can dial any value supported by the sensor. set_iso_free(value=None) set_shutter_a_free(value=None) set_fps_free(value=None) set_wb_free(value=None)","title":"Free\u2011mode toggles"},{"location":"controller-methods/#sensorspecific-tools","text":"set_filter(value=None) \u2013 Enable or disable the StarlightEye IR cut filter (IMX585 sensors only).","title":"Sensor\u2011specific tools"},{"location":"coverpage/","text":"Built: 2025-07-29 13:06 UTC","title":"Cinemate Documentation"},{"location":"digital-zoom/","text":"","title":"Digital zoom"},{"location":"dual-sensors/","text":"Dual sensors # CineMate automatically detects each camera connected to the Raspberry Pi and spawns a separate cinepi-raw process per sensor. By default: Primary camera (first detected) displays its preview on HDMI port 0. Secondary cameras run with --nopreview and map to subsequent HDMI outputs (cam1\u2192HDMI 1, cam2\u2192HDMI 2, etc.). Preview windows are centered and sized according to your geometry settings. Cameras are synchronized with cam0 being the server and cam1 being the client. You can override default HDMI mappings in settings.json under the output section.","title":"Dual sensors"},{"location":"dual-sensors/#dual-sensors","text":"CineMate automatically detects each camera connected to the Raspberry Pi and spawns a separate cinepi-raw process per sensor. By default: Primary camera (first detected) displays its preview on HDMI port 0. Secondary cameras run with --nopreview and map to subsequent HDMI outputs (cam1\u2192HDMI 1, cam2\u2192HDMI 2, etc.). Preview windows are centered and sized according to your geometry settings. Cameras are synchronized with cam0 being the server and cam1 being the client. You can override default HDMI mappings in settings.json under the output section.","title":"Dual sensors"},{"location":"getting-started/","text":"Quick start # Hardware requirements # Raspberry Pi 5 Official HQ or Global Shutter camera HDMI monitor or a phone/tablet for monitoring Installation # Burn the Cinemate image to an SD card (8 GB or larger). Connect the Pi and the camera sensor board. Important: Ensure the Pi is powered off before attaching the camera ribbon cable. Hot-swapping the cable is not advised. Boot the Pi. CineMate should start automatically. Previewing the image Plug in an HDMI monitor or connect your phone/tablet to the Wi\u2011Fi network CinePi (password 11111111 ). Open a browser and go to cinepi.local:5000 to see the interface. A clean video feed without the GUI is available at cinepi.local:8000/stream . Recording footage Attach a high\u2011speed drive: an SSD (Samsung T7 recommended), an NVMe drive , or the CFE Hat . Format the drive as ext4 and give it the label RAW . Connect a button between GPIO5 and GND (or briefly short these pins with a paper clip). When using the phone preview, you can also start/stop recording by tapping the preview. That's it\u2014your bare\u2011bones CineMate build is ready! Remember to power everything down before disconnecting hardware!","title":"Getting started with a minimal build"},{"location":"getting-started/#quick-start","text":"","title":"Quick start"},{"location":"getting-started/#hardware-requirements","text":"Raspberry Pi 5 Official HQ or Global Shutter camera HDMI monitor or a phone/tablet for monitoring","title":"Hardware requirements"},{"location":"getting-started/#installation","text":"Burn the Cinemate image to an SD card (8 GB or larger). Connect the Pi and the camera sensor board. Important: Ensure the Pi is powered off before attaching the camera ribbon cable. Hot-swapping the cable is not advised. Boot the Pi. CineMate should start automatically. Previewing the image Plug in an HDMI monitor or connect your phone/tablet to the Wi\u2011Fi network CinePi (password 11111111 ). Open a browser and go to cinepi.local:5000 to see the interface. A clean video feed without the GUI is available at cinepi.local:8000/stream . Recording footage Attach a high\u2011speed drive: an SSD (Samsung T7 recommended), an NVMe drive , or the CFE Hat . Format the drive as ext4 and give it the label RAW . Connect a button between GPIO5 and GND (or briefly short these pins with a paper clip). When using the phone preview, you can also start/stop recording by tapping the preview. That's it\u2014your bare\u2011bones CineMate build is ready! Remember to power everything down before disconnecting hardware!","title":"Installation"},{"location":"hardware-controls/","text":"","title":"Adding hardware controls"},{"location":"hardware-introduction/","text":"","title":"Hardware introduction"},{"location":"hotspot-logic/","text":"Configuring the Wi-Fi hotspot # The built\u2011in hotspot ensures you can always reach Cinemate even when there is no other network available. When wifi_hotspot in settings.json is set to true and no hotspot is active, Cinemate runs nmcli device wifi hotspot using your chosen SSID and password. This is handy when shooting in the field. Connect your phone or laptop directly to the hotspot and browse to the GUI to control the camera. If the Pi was previously connected to a Wi\u2011Fi network, that connection is replaced by the hotspot. During development you may want the Pi to join your normal Wi\u2011Fi so it has internet access. Set system.wifi_hotspot.enabled to false and configure Wi\u2011Fi through raspi-config or the desktop tools. The web interface will appear on the Pi's regular network address, letting you stay connected to both the Pi and the internet. If you plug an Ethernet cable into the Pi, you can keep the hotspot running while also having a wired connection for internet and local networking. Note that Cinemate still streams its web gui on whatever network the Pi is connected to, with GUI at :5000 and clean preview without GUI on :8000/stream","title":"Configuring the Wi-Fi hotspot"},{"location":"hotspot-logic/#configuring-the-wi-fi-hotspot","text":"The built\u2011in hotspot ensures you can always reach Cinemate even when there is no other network available. When wifi_hotspot in settings.json is set to true and no hotspot is active, Cinemate runs nmcli device wifi hotspot using your chosen SSID and password. This is handy when shooting in the field. Connect your phone or laptop directly to the hotspot and browse to the GUI to control the camera. If the Pi was previously connected to a Wi\u2011Fi network, that connection is replaced by the hotspot. During development you may want the Pi to join your normal Wi\u2011Fi so it has internet access. Set system.wifi_hotspot.enabled to false and configure Wi\u2011Fi through raspi-config or the desktop tools. The web interface will appear on the Pi's regular network address, letting you stay connected to both the Pi and the internet. If you plug an Ethernet cable into the Pi, you can keep the hotspot running while also having a wired connection for internet and local networking. Note that Cinemate still streams its web gui on whatever network the Pi is connected to, with GUI at :5000 and clean preview without GUI on :8000/stream","title":"Configuring the Wi-Fi hotspot"},{"location":"image-circle/","text":"","title":"Image circle"},{"location":"installation-steps%20copy%202/","text":"Installation # Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Although Raspberry Pi 4 (and even 3) has been known to work with the stack below, a Raspopberry Pi 5B or Compute Module 5 is recommended. Also note that for high speed USB 3, a Raspberry Pi 4 or 5 is needed. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.34 (this is what you get with the official Raspberry Pi imager and doing a sudo apt update && sudo apt upgrade). If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt-get install python3-jinja2 python3-ply python3-yaml Manual install # Tools & dependencies # sudo apt update && sudo apt upgrade sudo apt install -y cmake libepoxy-dev libavdevice-dev build-essential cmake libboost-program-options-dev libdrm-dev libexif-dev libcamera-dev libjpeg-dev libtiff5-dev libpng-dev redis-server libhiredis-dev libasound2-dev libjsoncpp-dev libpng-dev meson ninja-build libavcodec-dev libavdevice-dev libavformat-dev libswresample-dev && sudo apt-get install libjsoncpp-dev && cd ~ && git clone https://github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~ libcamera 1.7.0 # sudo apt install -y python3-pip git python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install cpp-mjpeg-streamer # sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd CinePi-raw # git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF imx585 driver # sudo apt install linux-headers dkms git git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye Add the IMX585 tuning files (optional) # curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/ IR filter switch script (optional) # sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate imx283 driver # sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh The imx283 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/imx283-v4l2-driver Enabling I\u00b2C # sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules. Setting hostname # sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates Add camera modules to config.txt # sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to. # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1 Change the console font (optional) # sudo apt update sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose Terminus / 16x32 Verify /etc/default/console-setup contains: FONTFACE=\"Terminus\" FONTSIZE=\"16x32\" Then enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor Create post-processing configs # Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json Install PiShrink # wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions Reboot: # sudo reboot Trying out CinePi from the terminal # You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section . Cinemate # Create a Python virtual environment # sudo apt update && sudo apt install -y python3-venv python3 -m venv /home/pi/.cinemate-env echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc source /home/pi/.cinemate-env/bin/activate Grant sudo privileges and enable I\u00b2C # echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: reboot Dependencies # python3 -m pip install --upgrade pip setuptools wheel sudo apt-get install -y i2c-tools portaudio19-dev build-essential python3-dev python3-pip python3-smbus python3-serial git pip3 install adafruit-circuitpython-ssd1306 watchdog psutil Pillow redis keyboard pyudev sounddevice smbus2 gpiozero RPI.GPIO evdev termcolor pyserial inotify_simple numpy rpi_hardware_pwm pip3 uninstall -y Pillow && pip3 install Pillow pip3 install sugarpie flask_socketio adafruit-blinka adafruit-circuitpython-seesaw luma.oled grove.py pigpio-encoder gpiod sudo apt install python3-systemd e2fsprogs ntfs-3g exfatprogs console-terminus If you previously installed the board Python package, remove it with pip3 uninstall board . Replace RPi.GPIO with lgpio # sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio Clone the Cinemate repo # git clone https://github.com/Tiramisioux/cinemate.git Allow Cinemate to run with sudo # Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x Enable NetworkManager # sudo systemctl enable NetworkManager --now Rotate logs # Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP Seed Redis with default keys # redis-cli <<'EOF' SET anamorphic_factor 1.0 PUBLISH cp_controls anamorphic_factor SET bit_depth 12 PUBLISH cp_controls bit_depth EOF (See the settings guide for the full list.) Add a convenience alias # nano ~/.bashrc add to the end of the file # alias cinemate = 'python3 /home/pi/cinemate/src/main.py' Exit with Ctrl+x Reload .bashrc source ~/.bashrc Cinemate services # Cinemate with two small helper services under services/ : storage-automount # Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. Partitions named RAW are attached at /media/RAW ; all others are mounted under /media/<LABEL> . wifi-hotspot # keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI even without other networking. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make enable Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] ... Connect to the Pi: ssh pi@10.42.0.1 # password: 1 Starting Cinemate # Initializing Redis Keys # This has only to be done once on your system: redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 2 .5,2.2 \\ file_size 0 fps 1 fps_actual 1 fps_last 1 fps_max 1 fps_user 1 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 0 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ trigger_mode 0 wb 0 wb_user 0 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service: cinemate-autostart.service # cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. Thinking about the wifi-hotspot service The optional wifi-hotspot service gives the Pi its own wireless network so you can always connect to the web interface. It is great for field work where there may be no existing network. Simply join the CinePi network on your phone or laptop and browse to the GUI. During development you might prefer the Pi to use your normal Wi\u2011Fi instead so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false in settings.json or by stopping the service with sudo systemctl stop wifi-hotspot . If you plug in an Ethernet cable you can keep the hotspot active while the wired connection provides internet access. See Hotspot logic for more details on how the hotspot works.","title":"Installation"},{"location":"installation-steps%20copy%202/#installation","text":"Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Although Raspberry Pi 4 (and even 3) has been known to work with the stack below, a Raspopberry Pi 5B or Compute Module 5 is recommended. Also note that for high speed USB 3, a Raspberry Pi 4 or 5 is needed. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.34 (this is what you get with the official Raspberry Pi imager and doing a sudo apt update && sudo apt upgrade). If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt-get install python3-jinja2 python3-ply python3-yaml","title":"Installation"},{"location":"installation-steps%20copy%202/#manual-install","text":"","title":"Manual install"},{"location":"installation-steps%20copy%202/#tools-dependencies","text":"sudo apt update && sudo apt upgrade sudo apt install -y cmake libepoxy-dev libavdevice-dev build-essential cmake libboost-program-options-dev libdrm-dev libexif-dev libcamera-dev libjpeg-dev libtiff5-dev libpng-dev redis-server libhiredis-dev libasound2-dev libjsoncpp-dev libpng-dev meson ninja-build libavcodec-dev libavdevice-dev libavformat-dev libswresample-dev && sudo apt-get install libjsoncpp-dev && cd ~ && git clone https://github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~","title":"Tools &amp; dependencies"},{"location":"installation-steps%20copy%202/#libcamera-170","text":"sudo apt install -y python3-pip git python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install","title":"libcamera 1.7.0"},{"location":"installation-steps%20copy%202/#cpp-mjpeg-streamer","text":"sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd","title":"cpp-mjpeg-streamer"},{"location":"installation-steps%20copy%202/#cinepi-raw","text":"git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF","title":"CinePi-raw"},{"location":"installation-steps%20copy%202/#imx585-driver","text":"sudo apt install linux-headers dkms git git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye","title":"imx585 driver"},{"location":"installation-steps%20copy%202/#add-the-imx585-tuning-files-optional","text":"curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/","title":"Add the IMX585 tuning files (optional)"},{"location":"installation-steps%20copy%202/#ir-filter-switch-script-optional","text":"sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate","title":"IR filter switch script (optional)"},{"location":"installation-steps%20copy%202/#imx283-driver","text":"sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh The imx283 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/imx283-v4l2-driver","title":"imx283 driver"},{"location":"installation-steps%20copy%202/#enabling-i2c","text":"sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules.","title":"Enabling I\u00b2C"},{"location":"installation-steps%20copy%202/#setting-hostname","text":"sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates","title":"Setting hostname"},{"location":"installation-steps%20copy%202/#add-camera-modules-to-configtxt","text":"sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to. # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1","title":"Add camera modules to config.txt"},{"location":"installation-steps%20copy%202/#change-the-console-font-optional","text":"sudo apt update sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose Terminus / 16x32 Verify /etc/default/console-setup contains: FONTFACE=\"Terminus\" FONTSIZE=\"16x32\" Then enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor","title":"Change the console font (optional)"},{"location":"installation-steps%20copy%202/#create-post-processing-configs","text":"Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json","title":"Create post-processing configs"},{"location":"installation-steps%20copy%202/#install-pishrink","text":"wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions","title":"Install PiShrink"},{"location":"installation-steps%20copy%202/#reboot","text":"sudo reboot","title":"Reboot:"},{"location":"installation-steps%20copy%202/#trying-out-cinepi-from-the-terminal","text":"You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section .","title":"Trying out CinePi from the terminal"},{"location":"installation-steps%20copy%202/#cinemate","text":"","title":"Cinemate"},{"location":"installation-steps%20copy%202/#create-a-python-virtual-environment","text":"sudo apt update && sudo apt install -y python3-venv python3 -m venv /home/pi/.cinemate-env echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc source /home/pi/.cinemate-env/bin/activate","title":"Create a Python virtual environment"},{"location":"installation-steps%20copy%202/#grant-sudo-privileges-and-enable-i2c","text":"echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: reboot","title":"Grant sudo privileges and enable I\u00b2C"},{"location":"installation-steps%20copy%202/#dependencies","text":"python3 -m pip install --upgrade pip setuptools wheel sudo apt-get install -y i2c-tools portaudio19-dev build-essential python3-dev python3-pip python3-smbus python3-serial git pip3 install adafruit-circuitpython-ssd1306 watchdog psutil Pillow redis keyboard pyudev sounddevice smbus2 gpiozero RPI.GPIO evdev termcolor pyserial inotify_simple numpy rpi_hardware_pwm pip3 uninstall -y Pillow && pip3 install Pillow pip3 install sugarpie flask_socketio adafruit-blinka adafruit-circuitpython-seesaw luma.oled grove.py pigpio-encoder gpiod sudo apt install python3-systemd e2fsprogs ntfs-3g exfatprogs console-terminus If you previously installed the board Python package, remove it with pip3 uninstall board .","title":"Dependencies"},{"location":"installation-steps%20copy%202/#replace-rpigpio-with-lgpio","text":"sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio","title":"Replace RPi.GPIO with lgpio"},{"location":"installation-steps%20copy%202/#clone-the-cinemate-repo","text":"git clone https://github.com/Tiramisioux/cinemate.git","title":"Clone the Cinemate repo"},{"location":"installation-steps%20copy%202/#allow-cinemate-to-run-with-sudo","text":"Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x","title":"Allow Cinemate to run with sudo"},{"location":"installation-steps%20copy%202/#enable-networkmanager","text":"sudo systemctl enable NetworkManager --now","title":"Enable NetworkManager"},{"location":"installation-steps%20copy%202/#rotate-logs","text":"Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP","title":"Rotate logs"},{"location":"installation-steps%20copy%202/#seed-redis-with-default-keys","text":"redis-cli <<'EOF' SET anamorphic_factor 1.0 PUBLISH cp_controls anamorphic_factor SET bit_depth 12 PUBLISH cp_controls bit_depth EOF (See the settings guide for the full list.)","title":"Seed Redis with default keys"},{"location":"installation-steps%20copy%202/#add-a-convenience-alias","text":"nano ~/.bashrc","title":"Add a convenience alias"},{"location":"installation-steps%20copy%202/#add-to-the-end-of-the-file","text":"alias cinemate = 'python3 /home/pi/cinemate/src/main.py' Exit with Ctrl+x Reload .bashrc source ~/.bashrc","title":"add to the end of the file"},{"location":"installation-steps%20copy%202/#cinemate-services","text":"Cinemate with two small helper services under services/ :","title":"Cinemate services"},{"location":"installation-steps%20copy%202/#storage-automount","text":"Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. Partitions named RAW are attached at /media/RAW ; all others are mounted under /media/<LABEL> .","title":"storage-automount"},{"location":"installation-steps%20copy%202/#wifi-hotspot","text":"keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI even without other networking. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make enable Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] ... Connect to the Pi: ssh pi@10.42.0.1 # password: 1","title":"wifi-hotspot"},{"location":"installation-steps%20copy%202/#starting-cinemate","text":"","title":"Starting Cinemate"},{"location":"installation-steps%20copy%202/#initializing-redis-keys","text":"This has only to be done once on your system: redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 2 .5,2.2 \\ file_size 0 fps 1 fps_actual 1 fps_last 1 fps_max 1 fps_user 1 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 0 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ trigger_mode 0 wb 0 wb_user 0 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service:","title":"Initializing Redis Keys"},{"location":"installation-steps%20copy%202/#cinemate-autostartservice","text":"cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. Thinking about the wifi-hotspot service The optional wifi-hotspot service gives the Pi its own wireless network so you can always connect to the web interface. It is great for field work where there may be no existing network. Simply join the CinePi network on your phone or laptop and browse to the GUI. During development you might prefer the Pi to use your normal Wi\u2011Fi instead so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false in settings.json or by stopping the service with sudo systemctl stop wifi-hotspot . If you plug in an Ethernet cable you can keep the hotspot active while the wired connection provides internet access. See Hotspot logic for more details on how the hotspot works.","title":"cinemate-autostart.service"},{"location":"installation-steps%20copy/","text":"Manual installation # Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Although Raspberry Pi 4 (and even 3) has been known to work with the stack below, a Raspopberry Pi 5B or Compute Module 5 is recommended. Also note that for high speed USB 3, a Raspberry Pi 4 or 5 is needed. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.20+. If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt install -y python-pip git python3-jinja2 libcamera 1.7.0 # git clone https://github.com/raspberrypi/libcamera && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install && \\ cd cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig sudo apt install -y python3-pip git python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 nvm # wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash source ~/.bashrc nvm install --lts Cinemate uses nvm (Node Version Manager) for its web ui. If you plan to use cionepi-raw only, nvm is not needed. cpp-mjpeg-streamer # sudo apt install -y libspdlog-dev libjsoncpp-dev cd /home/pi git clone https://github.com/Tiramisioux/cpp-mjpeg-streamer.git --branch cinemate cd cpp-mjpeg-streamer && mkdir build && cd build cmake .. && make make install-here Cinemate uses a custom fork of cpp-mjpeg-streamer. If you plan to use only cinepi-raw, you can use the original app found at https://github.com/nadjieb/cpp-mjpeg-streamer CinePi-raw # Dependencies # sudo apt install -y cmake libepoxy-dev libavdevice-dev build-essential cmake libboost-program-options-dev libdrm-dev libexif-dev libcamera-dev libjpeg-dev libtiff5-dev libpng-dev redis-server libhiredis-dev libasound2-dev libjsoncpp-dev libpng-dev meson ninja-build libavcodec-dev libavdevice-dev libavformat-dev libswresample-dev && sudo apt-get install libjsoncpp-dev && cd ~ && git clone https://github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~ cinepi-raw # git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd /home/pi/cinepi-raw sudo rm -rf build ( if you have a previous build ) export PKG_CONFIG_PATH = /home/pi/cpp-mjpeg-streamer/build: $PKG_CONFIG_PATH sudo meson setup build sudo ninja -C build sudo meson install -C build Cinemate depends on a custom branch of cinepi-raw created by Csaba Nagy. If you plan to use the original version you can find it adapted for rpicam-apps 0.7 here: https://github.com/Tiramisioux/cinepi-raw/tree/rpicam-apps_1.7 Join the CinePi Discord here ! imx585 driver # sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx585-v4l2-driver.git cd imx585-v4l2-driver/ ./setup.sh The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye imx283 driver # sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh The imx283 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/imx283-v4l2-driver Enabling I\u00b2C # sudo apt update && apt upgrade sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules. Hostname # sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates Add camera modules to config.txt # sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to. # Raspberry Pi HQ camera #camera_auto_detect=1 #dtoverlay=imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye camera_auto_detect = 0 dtoverlay = imx585,cam0 # StarlightEye Mono camera_auto_detect = 0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1 Add the IMX585 tuning file (optional) # curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json # cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ For the mono sensor use imx585_mono.json instead. IR filter switch script (optional) # wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate Change the console font (optional) # sudi apt update sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose Terminus / 16x32 Verify /etc/default/console-setup contains: FONTFACE=\"Terminus\" FONTSIZE=\"16x32\" Then enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor Create post-processing configs # Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json Install PiShrink # wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions Reboot before installing Cinemate: # reboot You should now have a working install of cinepi-raw. To try it out, see this section [TBA] To continue installing Cinemate, follow the steps below: Create a Python virtual environment # sudo apt update && apt install -y python3-venv python3 -m venv /home/pi/.cinemate-env echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc source /home/pi/.cinemate-env/bin/activate Grant sudo privileges and enable I\u00b2C # echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: reboot Cinemate # Dependencies # source /home/pi/.cinemate-env/bin/activate python3 -m pip install --upgrade pip setuptools wheel sudo apt-get install -y i2c-tools portaudio19-dev build-essential python3-dev python3-pip python3-smbus python3-serial git pip3 install adafruit-circuitpython-ssd1306 watchdog psutil Pillow redis keyboard pyudev sounddevice smbus2 gpiozero RPI.GPIO evdev termcolor pyserial inotify_simple numpy rpi_hardware_pwm pip3 uninstall -y Pillow && pip3 install Pillow pip3 install sugarpie flask_socketio adafruit-blinka adafruit-circuitpython-seesaw luma.oled grove.py pigpio-encoder gpiod sudo apt install python3-systemd e2fsprogs ntfs-3g exfatprogs console-terminus If you previously installed the board Python package, remove it with pip3 uninstall board . Replace RPi.GPIO with lgpio # sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio Clone the Cinemate repo # git clone https://github.com/Tiramisioux/cinemate.git Allow Cinemates main.py to run with sudo # Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Enable NetworkManager # sudo systemctl enable NetworkManager --now Rotate logs # Paste this into the terminal and hit enter: # tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP Seed Redis with default keys # redis-cli <<'EOF' SET anamorphic_factor 1.0 PUBLISH cp_controls anamorphic_factor SET bit_depth 12 PUBLISH cp_controls bit_depth ... EOF (See the settings guide for the full list.) Add a convenience alias # Append to ~/.bashrc : alias Cinemate = 'python3 /home/pi/Cinemate/src/main.py' Then, inside cinemate folder: make install Cinemate services # Cinemate with two small helper services under services/ : storage-automount \u2013 mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. Partitions named RAW are attached at /media/RAW ; all others are mounted under /media/<LABEL> . wifi-hotspot \u2013 keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI even without other networking. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make enable You can manage each one individually with make <action>-<service> , for example make status-wifi-hotspot . Starting Cinemate # If you are not using the service file for autostart, anywhere in the terminal, type: cinemate This would be the recommended way of trying out Cinemate as you will get extended logging in the terminal which can be helpful when troubleshooting. The Cinemate logger also relays logging messages from the running cinepi-raw instance.","title":"Manual installation"},{"location":"installation-steps%20copy/#manual-installation","text":"Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Although Raspberry Pi 4 (and even 3) has been known to work with the stack below, a Raspopberry Pi 5B or Compute Module 5 is recommended. Also note that for high speed USB 3, a Raspberry Pi 4 or 5 is needed. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.20+. If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt install -y python-pip git python3-jinja2","title":"Manual installation"},{"location":"installation-steps%20copy/#libcamera-170","text":"git clone https://github.com/raspberrypi/libcamera && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install && \\ cd cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig sudo apt install -y python3-pip git python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59","title":"libcamera 1.7.0"},{"location":"installation-steps%20copy/#nvm","text":"wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash source ~/.bashrc nvm install --lts Cinemate uses nvm (Node Version Manager) for its web ui. If you plan to use cionepi-raw only, nvm is not needed.","title":"nvm"},{"location":"installation-steps%20copy/#cpp-mjpeg-streamer","text":"sudo apt install -y libspdlog-dev libjsoncpp-dev cd /home/pi git clone https://github.com/Tiramisioux/cpp-mjpeg-streamer.git --branch cinemate cd cpp-mjpeg-streamer && mkdir build && cd build cmake .. && make make install-here Cinemate uses a custom fork of cpp-mjpeg-streamer. If you plan to use only cinepi-raw, you can use the original app found at https://github.com/nadjieb/cpp-mjpeg-streamer","title":"cpp-mjpeg-streamer"},{"location":"installation-steps%20copy/#cinepi-raw","text":"","title":"CinePi-raw"},{"location":"installation-steps%20copy/#dependencies","text":"sudo apt install -y cmake libepoxy-dev libavdevice-dev build-essential cmake libboost-program-options-dev libdrm-dev libexif-dev libcamera-dev libjpeg-dev libtiff5-dev libpng-dev redis-server libhiredis-dev libasound2-dev libjsoncpp-dev libpng-dev meson ninja-build libavcodec-dev libavdevice-dev libavformat-dev libswresample-dev && sudo apt-get install libjsoncpp-dev && cd ~ && git clone https://github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~","title":"Dependencies"},{"location":"installation-steps%20copy/#cinepi-raw_1","text":"git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd /home/pi/cinepi-raw sudo rm -rf build ( if you have a previous build ) export PKG_CONFIG_PATH = /home/pi/cpp-mjpeg-streamer/build: $PKG_CONFIG_PATH sudo meson setup build sudo ninja -C build sudo meson install -C build Cinemate depends on a custom branch of cinepi-raw created by Csaba Nagy. If you plan to use the original version you can find it adapted for rpicam-apps 0.7 here: https://github.com/Tiramisioux/cinepi-raw/tree/rpicam-apps_1.7 Join the CinePi Discord here !","title":"cinepi-raw"},{"location":"installation-steps%20copy/#imx585-driver","text":"sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx585-v4l2-driver.git cd imx585-v4l2-driver/ ./setup.sh The imx585 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/StarlightEye","title":"imx585 driver"},{"location":"installation-steps%20copy/#imx283-driver","text":"sudo apt install linux-headers dkms git git clone https://github.com/Tiramisioux/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh The imx283 is written by Will Whang. For original drivers and startup guides, visit https://github.com/will127534/imx283-v4l2-driver","title":"imx283 driver"},{"location":"installation-steps%20copy/#enabling-i2c","text":"sudo apt update && apt upgrade sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules.","title":"Enabling I\u00b2C"},{"location":"installation-steps%20copy/#hostname","text":"sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates","title":"Hostname"},{"location":"installation-steps%20copy/#add-camera-modules-to-configtxt","text":"sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to. # Raspberry Pi HQ camera #camera_auto_detect=1 #dtoverlay=imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye camera_auto_detect = 0 dtoverlay = imx585,cam0 # StarlightEye Mono camera_auto_detect = 0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1","title":"Add camera modules to config.txt"},{"location":"installation-steps%20copy/#add-the-imx585-tuning-file-optional","text":"curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json # cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ For the mono sensor use imx585_mono.json instead.","title":"Add the IMX585 tuning file (optional)"},{"location":"installation-steps%20copy/#ir-filter-switch-script-optional","text":"wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate","title":"IR filter switch script (optional)"},{"location":"installation-steps%20copy/#change-the-console-font-optional","text":"sudi apt update sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose Terminus / 16x32 Verify /etc/default/console-setup contains: FONTFACE=\"Terminus\" FONTSIZE=\"16x32\" Then enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor","title":"Change the console font (optional)"},{"location":"installation-steps%20copy/#create-post-processing-configs","text":"Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json","title":"Create post-processing configs"},{"location":"installation-steps%20copy/#install-pishrink","text":"wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions","title":"Install PiShrink"},{"location":"installation-steps%20copy/#reboot-before-installing-cinemate","text":"reboot You should now have a working install of cinepi-raw. To try it out, see this section [TBA] To continue installing Cinemate, follow the steps below:","title":"Reboot before installing Cinemate:"},{"location":"installation-steps%20copy/#create-a-python-virtual-environment","text":"sudo apt update && apt install -y python3-venv python3 -m venv /home/pi/.cinemate-env echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc source /home/pi/.cinemate-env/bin/activate","title":"Create a Python virtual environment"},{"location":"installation-steps%20copy/#grant-sudo-privileges-and-enable-i2c","text":"echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: reboot","title":"Grant sudo privileges and enable I\u00b2C"},{"location":"installation-steps%20copy/#cinemate","text":"","title":"Cinemate"},{"location":"installation-steps%20copy/#dependencies_1","text":"source /home/pi/.cinemate-env/bin/activate python3 -m pip install --upgrade pip setuptools wheel sudo apt-get install -y i2c-tools portaudio19-dev build-essential python3-dev python3-pip python3-smbus python3-serial git pip3 install adafruit-circuitpython-ssd1306 watchdog psutil Pillow redis keyboard pyudev sounddevice smbus2 gpiozero RPI.GPIO evdev termcolor pyserial inotify_simple numpy rpi_hardware_pwm pip3 uninstall -y Pillow && pip3 install Pillow pip3 install sugarpie flask_socketio adafruit-blinka adafruit-circuitpython-seesaw luma.oled grove.py pigpio-encoder gpiod sudo apt install python3-systemd e2fsprogs ntfs-3g exfatprogs console-terminus If you previously installed the board Python package, remove it with pip3 uninstall board .","title":"Dependencies"},{"location":"installation-steps%20copy/#replace-rpigpio-with-lgpio","text":"sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio","title":"Replace RPi.GPIO with lgpio"},{"location":"installation-steps%20copy/#clone-the-cinemate-repo","text":"git clone https://github.com/Tiramisioux/cinemate.git","title":"Clone the Cinemate repo"},{"location":"installation-steps%20copy/#allow-cinemates-mainpy-to-run-with-sudo","text":"Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4","title":"Allow Cinemates main.py to run with sudo"},{"location":"installation-steps%20copy/#enable-networkmanager","text":"sudo systemctl enable NetworkManager --now","title":"Enable NetworkManager"},{"location":"installation-steps%20copy/#rotate-logs","text":"Paste this into the terminal and hit enter: # tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP","title":"Rotate logs"},{"location":"installation-steps%20copy/#seed-redis-with-default-keys","text":"redis-cli <<'EOF' SET anamorphic_factor 1.0 PUBLISH cp_controls anamorphic_factor SET bit_depth 12 PUBLISH cp_controls bit_depth ... EOF (See the settings guide for the full list.)","title":"Seed Redis with default keys"},{"location":"installation-steps%20copy/#add-a-convenience-alias","text":"Append to ~/.bashrc : alias Cinemate = 'python3 /home/pi/Cinemate/src/main.py' Then, inside cinemate folder: make install","title":"Add a convenience alias"},{"location":"installation-steps%20copy/#cinemate-services","text":"Cinemate with two small helper services under services/ : storage-automount \u2013 mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. Partitions named RAW are attached at /media/RAW ; all others are mounted under /media/<LABEL> . wifi-hotspot \u2013 keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI even without other networking. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make enable You can manage each one individually with make <action>-<service> , for example make status-wifi-hotspot .","title":"Cinemate services"},{"location":"installation-steps%20copy/#starting-cinemate","text":"If you are not using the service file for autostart, anywhere in the terminal, type: cinemate This would be the recommended way of trying out Cinemate as you will get extended logging in the terminal which can be helpful when troubleshooting. The Cinemate logger also relays logging messages from the running cinepi-raw instance.","title":"Starting Cinemate"},{"location":"installation-steps/","text":"Installation # Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Stack is confirmed to work on Raspberry pi 4 and 5 models. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.34. If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt-get install python3-jinja2 python3-ply python3-yaml Camera stack # Tools & dependencies # sudo apt update -y sudo apt upgrade -y sudo apt install -y git cmake libepoxy-dev libavdevice-dev build-essential cmake libboost-program-options-dev libdrm-dev libexif-dev libcamera-dev libjpeg-dev libtiff5-dev libpng-dev redis-server libhiredis-dev libasound2-dev libjsoncpp-dev libpng-dev meson ninja-build libavcodec-dev libavdevice-dev libavformat-dev libswresample-dev && sudo apt-get install libjsoncpp-dev && cd ~ && git clone https://github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~ libcamera 1.7.0 # sudo apt install -y python3-pip python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install cpp-mjpeg-streamer # sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd CinePi-raw # git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd sudo ldconfig Seed Redis with white balance default keys # redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF Additional drivers # sudo apt install linux-headers dkms -y imx585 driver # git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh cd Add IMX585 tuning files # curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/ IR filter switch script # sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate imx283 driver # git clone https://github.com/will127534/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh cd Enabling I\u00b2C # sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules. Setting hostname # sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates Add camera modules to config.txt # sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to (example shows imx477 activated) # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Change the console font (optional) # sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose: UTF-8 # Guess optimal character set # Terminus # 16x32 (framebuffer only) Enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor Create post-processing configs # Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json Install PiShrink # wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions Reboot: # sudo reboot Trying out CinePi from the terminal # You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section . Cinemate # System wide packages # sudo apt update sudo apt install -y \\ git build-essential python3-dev python3-pip python3-venv \\ i2c-tools python3-smbus python3-pyudev \\ libgpiod-dev libgpiod2 python3-libgpiod gpiod \\ portaudio19-dev python3-systemd \\ e2fsprogs ntfs-3g exfatprogs \\ console-terminus Create a Python virtual environment # python3 -m venv ~/.cinemate-env source /home/pi/.cinemate-env/bin/activate echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc Grant sudo privileges and enable I\u00b2C # echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: sudo reboot Python packages # If you previously installed the board Python package, remove it with pip3 uninstall board . pip install \\ gpiozero \\ adafruit-blinka adafruit-circuitpython-ssd1306 adafruit-circuitpython-seesaw \\ luma.oled grove.py pigpio-encoder smbus2 rpi_hardware_pwm \\ watchdog psutil pillow redis keyboard pyudev numpy termcolor sounddevice \\ evdev inotify_simple sysv_ipc flask_socketio sugarpie Alternative GPIO back-end # sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio Clone the Cinemate repo # git clone https://github.com/Tiramisioux/cinemate.git --branch cinemate-3.1 Allow Cinemate to run with sudo # Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Enable NetworkManager # sudo systemctl enable NetworkManager --now Rotate logs # Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP Seed Redis with default keys # redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 3 .5,1.5 \\ file_size 0 fps 24 fps_actual 24 fps_last 24 fps_max 1 fps_user 24 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 100 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ wb 5600 wb_user 5600 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 (See the settings guide for the full list.) Add alias # nano ~/.bashrc Add to the end of the file: alias cinemate = 'python3 /home/pi/cinemate/src/main.py' Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Reload .bashrc source ~/.bashrc Cinemate services # storage-automount # Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT. wifi-hotspot # Keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI while in the field. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make start # starts the service sudo make enable # makes the service start on boot You can also start and enable the service individually, by entering their respective folders and issuing the sudo make command Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] ... During development/building your rig you might prefer the Pi to use your normal Wi\u2011Fi instead of its own hotspot so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false settings.json and by stopping the service with sudo systemctl stop wifi-hotspot . To stop the hotspot from starting on boot, type sudo systemctl disable wifi-hotspot . If you plug in an Ethernet cable you can keep the hotspot active while the wired connection provides internet access. See Hotspot logic for more details on how the hotspot works. Connect to the Pi (if not already connected): # ssh pi@10.42.0.1 # password: 1 Starting Cinemate # Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service: cinemate-autostart.service # cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. You now have a 12 bit RAW image capturing system on your Raspberry Pi!","title":"Manual installation (from scratch)"},{"location":"installation-steps/#installation","text":"Here is how you can manually install libcamera, cinepi-raw, cinemate and accompanying software on the Raspberry Pi. Stack is confirmed to work on Raspberry pi 4 and 5 models. This guide assumes fresh Raspbery Pi Bookworm installation running kernel 6.12.34. If you run Raspberry Pi OS Lite, begin by installing the following packages: sudo apt-get install python3-jinja2 python3-ply python3-yaml","title":"Installation"},{"location":"installation-steps/#camera-stack","text":"","title":"Camera stack"},{"location":"installation-steps/#tools-dependencies","text":"sudo apt update -y sudo apt upgrade -y sudo apt install -y git cmake libepoxy-dev libavdevice-dev build-essential cmake libboost-program-options-dev libdrm-dev libexif-dev libcamera-dev libjpeg-dev libtiff5-dev libpng-dev redis-server libhiredis-dev libasound2-dev libjsoncpp-dev libpng-dev meson ninja-build libavcodec-dev libavdevice-dev libavformat-dev libswresample-dev && sudo apt-get install libjsoncpp-dev && cd ~ && git clone https://github.com/sewenew/redis-plus-plus.git && cd redis-plus-plus && mkdir build && cd build && cmake .. && make && sudo make install && cd ~","title":"Tools &amp; dependencies"},{"location":"installation-steps/#libcamera-170","text":"sudo apt install -y python3-pip python3-jinja2 libboost-dev libgnutls28-dev openssl pybind11-dev qtbase5-dev libqt5core5a meson cmake python3-yaml python3-ply libglib2.0-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libavdevice59 sudo apt-get install --reinstall libtiff5-dev && sudo ln -sf $( find /usr/lib -name \"libtiff.so\" | head -n 1 ) /usr/lib/aarch64-linux-gnu/libtiff.so.5 && export LD_LIBRARY_PATH = /usr/lib/aarch64-linux-gnu: $LD_LIBRARY_PATH && sudo ldconfig git clone https://github.com/raspberrypi/libcamera.git && \\ sudo find ~/libcamera -type f \\( -name '*.py' -o -name '*.sh' \\) -exec chmod +x {} \\; && \\ cd libcamera && \\ sudo meson setup build --buildtype = release \\ -Dpipelines = rpi/vc4,rpi/pisp \\ -Dipas = rpi/vc4,rpi/pisp \\ -Dv4l2 = true \\ -Dgstreamer = enabled \\ -Dtest = false \\ -Dlc-compliance = disabled \\ -Dcam = disabled \\ -Dqcam = disabled \\ -Ddocumentation = disabled \\ -Dpycamera = enabled && \\ sudo ninja -C build install cd ~/libcamera/utils && sudo chmod +x *.py *.sh && sudo chmod +x ~/libcamera/src/ipa/ipa-sign.sh && cd ~/libcamera && sudo ninja -C build install","title":"libcamera 1.7.0"},{"location":"installation-steps/#cpp-mjpeg-streamer","text":"sudo apt install -y libspdlog-dev libjsoncpp-dev && cd /home/pi && git clone https://github.com/nadjieb/cpp-mjpeg-streamer.git && cd cpp-mjpeg-streamer && mkdir build && cd build && cmake .. && make && sudo make install && cd","title":"cpp-mjpeg-streamer"},{"location":"installation-steps/#cinepi-raw","text":"git clone https://github.com/Tiramisioux/cinepi-raw.git --branch rpicam-apps_1.7_custom_encoder cd cinepi-raw sudo rm -rf build sudo meson setup build sudo ninja -C build sudo meson install -C build cd sudo ldconfig","title":"CinePi-raw"},{"location":"installation-steps/#seed-redis-with-white-balance-default-keys","text":"redis-cli <<EOF SET cg_rb 2.5,2.2 PUBLISH cp_controls cg_rb EOF","title":"Seed Redis with white balance default keys"},{"location":"installation-steps/#additional-drivers","text":"sudo apt install linux-headers dkms -y","title":"Additional drivers"},{"location":"installation-steps/#imx585-driver","text":"git clone https://github.com/will127534/imx585-v4l2-driver.git --branch 6.12.y cd imx585-v4l2-driver/ ./setup.sh cd","title":"imx585 driver"},{"location":"installation-steps/#add-imx585-tuning-files","text":"curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json \\ https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585.json sed -i '8s/\"black_level\": *[0-9]\\+/\"black_level\": 0/' /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585.json /usr/local/share/libcamera/ipa/rpi/pisp/ curl -L -o /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json https://raw.githubusercontent.com/will127534/libcamera/master/src/ipa/rpi/pisp/data/imx585_mono.json && sudo cp /home/pi/libcamera/src/ipa/rpi/pisp/data/imx585_mono.json /usr/local/share/libcamera/ipa/rpi/pisp/","title":"Add IMX585 tuning files"},{"location":"installation-steps/#ir-filter-switch-script","text":"sudo wget https://raw.githubusercontent.com/will127534/StarlightEye/master/software/IRFilter -O /usr/local/bin/IRFilter sudo chmod +x /usr/local/bin/IRFilter Cinemate has its own way of handling the IR switch but the installation above can be convenient for use outside of Cinemate","title":"IR filter switch script"},{"location":"installation-steps/#imx283-driver","text":"git clone https://github.com/will127534/imx283-v4l2-driver.git cd imx283-v4l2-driver/ ./setup.sh cd","title":"imx283 driver"},{"location":"installation-steps/#enabling-i2c","text":"sudo raspi-config nonint do_i2c 0 Enabling I2C is needed for using the camera modules.","title":"Enabling I\u00b2C"},{"location":"installation-steps/#setting-hostname","text":"sudo hostnamectl set-hostname cinepi You will find the pi as cinepi.local on the local network, or at the hotspot Cinemate creates","title":"Setting hostname"},{"location":"installation-steps/#add-camera-modules-to-configtxt","text":"sudo nano /boot/firmware/config.txt Paste this into your file, and uncomment the sensor you are using. Also specify which physical camera port you have connected your sensor to (example shows imx477 activated) # Raspberry Pi HQ camera camera_auto_detect = 1 dtoverlay = imx477,cam0 # Raspberry Pi GS camera #camera_auto_detect=1 #dtoverlay=imx296,cam0 # OneInchEye #camera_auto_detect=0 #dtoverlay=imx283,cam0 # StarlightEye #camera_auto_detect=0 #dtoverlay=imx585,cam0 # StarlightEye Mono #camera_auto_detect=0 #dtoverlay=imx585,cam1,mono # CFE Hat (pi 5 only) dtparam = pciex1 dtparam = pciex1_gen = 3 dtoverlay = disable-bt And at the very bottom of the file: [ all ] avoid_warnings = 1 disable_splash = 1 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter.","title":"Add camera modules to config.txt"},{"location":"installation-steps/#change-the-console-font-optional","text":"sudo apt install console-setup kbd sudo dpkg-reconfigure console-setup # choose: UTF-8 # Guess optimal character set # Terminus # 16x32 (framebuffer only) Enable the service: sudo systemctl enable console-setup.service sudo systemctl start console-setup.service This can be useful if running the Pi on a small HD field monitor","title":"Change the console font (optional)"},{"location":"installation-steps/#create-post-processing-configs","text":"Paste this into the terminal and hit enter: sudo bash -c 'cat > post-processing.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing.json && \\ sudo bash -c 'cat > post-processing0.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8000 } } EOF' && \\ sudo chmod +x post-processing0.json && \\ sudo bash -c 'cat > post-processing1.json << EOF { \"sharedContext\": {}, \"mjpegPreview\": { \"port\": 8001 } } EOF' && \\ sudo chmod +x post-processing1.json","title":"Create post-processing configs"},{"location":"installation-steps/#install-pishrink","text":"wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh sudo install -m755 pishrink.sh /usr/local/bin/pishrink PiShrink is a great tool for compressing SD image file backups of the SD card. See here for instructions","title":"Install PiShrink"},{"location":"installation-steps/#reboot","text":"sudo reboot","title":"Reboot:"},{"location":"installation-steps/#trying-out-cinepi-from-the-terminal","text":"You should now have a working install of cinepi-raw. To see if your camera is recognized by the system: cinepi-raw --list-cameras Try it out with a simple cli command: cinepi-raw --mode 2028 :1080:12:U --width 2028 --height 1080 --lores-width 1280 --lores-height 720 For more details on running CinePi-raw from the command line, see this section .","title":"Trying out CinePi from the terminal"},{"location":"installation-steps/#cinemate","text":"","title":"Cinemate"},{"location":"installation-steps/#system-wide-packages","text":"sudo apt update sudo apt install -y \\ git build-essential python3-dev python3-pip python3-venv \\ i2c-tools python3-smbus python3-pyudev \\ libgpiod-dev libgpiod2 python3-libgpiod gpiod \\ portaudio19-dev python3-systemd \\ e2fsprogs ntfs-3g exfatprogs \\ console-terminus","title":"System wide packages"},{"location":"installation-steps/#create-a-python-virtual-environment","text":"python3 -m venv ~/.cinemate-env source /home/pi/.cinemate-env/bin/activate echo \"source /home/pi/.cinemate-env/bin/activate\" >> ~/.bashrc","title":"Create a Python virtual environment"},{"location":"installation-steps/#grant-sudo-privileges-and-enable-i2c","text":"echo \"pi ALL=(ALL) NOPASSWD: /home/pi/.cinemate-env/bin/*\" | sudo tee /etc/sudoers.d/cinemate-env sudo chown -R pi:pi /home/pi/.cinemate-env sudo chown -R pi:pi /media && chmod 755 /media sudo usermod -aG i2c pi sudo modprobe i2c-dev && echo i2c-dev | sudo tee -a /etc/modules echo \"pi ALL=(ALL) NOPASSWD: /home/pi/run_cinemate.sh\" | sudo tee -a /etc/sudoers.d/pi_cinemate Reboot so the group changes take effect: sudo reboot","title":"Grant sudo privileges and enable I\u00b2C"},{"location":"installation-steps/#python-packages","text":"If you previously installed the board Python package, remove it with pip3 uninstall board . pip install \\ gpiozero \\ adafruit-blinka adafruit-circuitpython-ssd1306 adafruit-circuitpython-seesaw \\ luma.oled grove.py pigpio-encoder smbus2 rpi_hardware_pwm \\ watchdog psutil pillow redis keyboard pyudev numpy termcolor sounddevice \\ evdev inotify_simple sysv_ipc flask_socketio sugarpie","title":"Python packages"},{"location":"installation-steps/#alternative-gpio-back-end","text":"sudo apt install -y swig python3-dev build-essential git git clone https://github.com/joan2937/lg cd lg && make sudo make install cd .. && pip install lgpio","title":"Alternative GPIO back-end"},{"location":"installation-steps/#clone-the-cinemate-repo","text":"git clone https://github.com/Tiramisioux/cinemate.git --branch cinemate-3.1","title":"Clone the Cinemate repo"},{"location":"installation-steps/#allow-cinemate-to-run-with-sudo","text":"Edit the sudoers file: sudo visudo add this to the end of the file: pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/main.py pi ALL=(ALL) NOPASSWD: /bin/mount, /bin/umount, /usr/bin/ntfs-3g pi ALL=(ALL) NOPASSWD: /home/pi/cinemate/src/logs/system.log pi ALL=(ALL) NOPASSWD: /sbin/mount.ext4 Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter.","title":"Allow Cinemate to run with sudo"},{"location":"installation-steps/#enable-networkmanager","text":"sudo systemctl enable NetworkManager --now","title":"Enable NetworkManager"},{"location":"installation-steps/#rotate-logs","text":"Paste this into the terminal and hit enter: sudo tee /etc/logrotate.d/general_logs <<'EOP' /var/log/*.log { size 100M rotate 5 compress missingok notifempty } EOP","title":"Rotate logs"},{"location":"installation-steps/#seed-redis-with-default-keys","text":"redis-cli MSET \\ anamorphic_factor 0 bit_depth 0 buffer 0 buffer_size 0 cam_init 0 cameras 0 cg_rb 3 .5,1.5 \\ file_size 0 fps 24 fps_actual 24 fps_last 24 fps_max 1 fps_user 24 framecount 0 \\ gui_layout 0 height 0 ir_filter 0 is_buffering 0 is_mounted 0 is_recording 0 \\ is_writing 0 is_writing_buf 0 tc_cam0 0 tc_cam1 0 iso 100 lores_height 0 lores_width 0 \\ pi_model 0 rec 0 sensor 0 sensor_mode 0 shutter_a 0 space_left 0 storage_type 0 \\ wb 5600 wb_user 5600 width 0 memory_alert 0 \\ shutter_a_sync_mode 0 shutter_angle_nom 0 shutter_angle_actual 0 shutter_angle_transient 0 \\ exposure_time 0 last_dng_cam1 0 last_dng_cam0 0 \\ zoom 0 write_speed_to_drive 0 recording_time 0 (See the settings guide for the full list.)","title":"Seed Redis with default keys"},{"location":"installation-steps/#add-alias","text":"nano ~/.bashrc Add to the end of the file: alias cinemate = 'python3 /home/pi/cinemate/src/main.py' Exit with Ctrl+x. System will ask you to save the file. Press \"y\" and then enter. Reload .bashrc source ~/.bashrc","title":"Add alias"},{"location":"installation-steps/#cinemate-services","text":"","title":"Cinemate services"},{"location":"installation-steps/#storage-automount","text":"Mounts and unmounts removable drives such as SSDs, NVMe enclosures and the CFE HAT.","title":"storage-automount"},{"location":"installation-steps/#wifi-hotspot","text":"Keeps a simple Wi\u2011Fi hotspot running via NetworkManager so you can reach the web UI while in the field. The SSID and password come from the system.wifi_hotspot section of settings.json . Install and enable both services with: cd /home/pi/cinemate/services sudo make install sudo make start # starts the service sudo make enable # makes the service start on boot You can also start and enable the service individually, by entering their respective folders and issuing the sudo make command Note that if you were connected to the Pi via wifi, this connection is now broken due to the Pi setting up its own hotspot. To connect again, check your available wifi networks. There should now be a network available named CinePi. Connect to it using password 11111111 Now you shuld be able to ssh to the Pi this command: ssh pi@cinepi.local You should also be able to find the Pi by opening a terminal and typing: arp -a You will see something like \u276f arp -a ? ( 10 .42.0.1 ) at e4:5f:1:a9:72:a7 on en0 ifscope [ ethernet ] ... During development/building your rig you might prefer the Pi to use your normal Wi\u2011Fi instead of its own hotspot so you remain online while tinkering. Disable the hotspot by setting system.wifi_hotspot.enabled to false settings.json and by stopping the service with sudo systemctl stop wifi-hotspot . To stop the hotspot from starting on boot, type sudo systemctl disable wifi-hotspot . If you plug in an Ethernet cable you can keep the hotspot active while the wired connection provides internet access. See Hotspot logic for more details on how the hotspot works.","title":"wifi-hotspot"},{"location":"installation-steps/#connect-to-the-pi-if-not-already-connected","text":"ssh pi@10.42.0.1 # password: 1","title":"Connect to the Pi (if not already connected):"},{"location":"installation-steps/#starting-cinemate","text":"Now, back on the Pi, anywhere in the terminal, type: cinemate Make sure things are running smoothly and then you can move on to enabling the cinemate-autostart service:","title":"Starting Cinemate"},{"location":"installation-steps/#cinemate-autostartservice","text":"cd /home/pi/cinemate/ sudo make install # copy service file sudo make enable # start on boot make start # launch now After enabling the service, Cinemate should autostart on boot. You now have a 12 bit RAW image capturing system on your Raspberry Pi!","title":"cinemate-autostart.service"},{"location":"known-issues/","text":"","title":"Known issues"},{"location":"links/","text":"","title":"Links"},{"location":"overclocking/","text":"Overclocking the Pi #","title":"Overclocking the Pi"},{"location":"overclocking/#overclocking-the-pi","text":"","title":"Overclocking the Pi"},{"location":"overview/","text":"Overview # Note TBA !!! example cinemate-cli --init --profile = 4k60","title":"Overview"},{"location":"overview/#overview","text":"Note TBA !!! example cinemate-cli --init --profile = 4k60","title":"Overview"},{"location":"preinstalled-hardware/","text":"Hardware overview # CineMate image file comes pre-installed with: - StarlightEye - CFE Hat - Grove Base HAT","title":"Hardware overview"},{"location":"preinstalled-hardware/#hardware-overview","text":"CineMate image file comes pre-installed with: - StarlightEye - CFE Hat - Grove Base HAT","title":"Hardware overview"},{"location":"redis-guide/","text":"Redis API quick start # Redis-cli # # List all keys redis-cli KEYS '*' # Read the current ISO value redis-cli GET iso # Start a recording (same as pressing the Rec button) redis-cli SET is_recording 1 redis-cli PUBLISH cp_controls is_recording You can also type: redis-cli This will open the redis cli. cp_controls # Both CinePi-raw and Cinemate writes values and immediately publish the key name. The recorder only reacts when it receives that publish event. Any key may be sent this way. For example, to adjust the preview zoom: # Set preview zoom level redis-cli SET zoom 1 .5 redis-cli PUBLISH cp_controls zoom Note that for the is_recording key Cinemate stops recording upon edge detection (the variable changes from 0 to 1 or vice versa). The reason for this exception has to do with how the CinePi-raw fork handles recording with multiple cameras # Start recording redis-cli SET is_recording 1 # triggers 0 \u2192 1 edge # Stop recording redis-cli SET is_recording 0 # triggers 1 \u2192 0 edge cp_stats # Every frame, cinepi-raw sends a small JSON object containing live statistics. Json :: Value data ; Json :: Value histo ; data [ \"framerate\" ] = completed_request -> framerate ; data [ \"colorTemp\" ] = info . colorTemp ; data [ \"focus\" ] = info . focus ; data [ \"frameCount\" ] = app_ -> GetEncoder () -> getFrameCount (); data [ \"bufferSize\" ] = app_ -> GetEncoder () -> bufferSize (); redis_ -> publish ( CHANNEL_STATS , data . toStyledString ()); CineMate\u2019s RedisListener parses these messages and updates Redis keys like framecount , BUFFER and fps_actual . Controlling the camera from your own script # Below is a very small example using redis-py . import redis r = redis . Redis ( host = 'localhost' , port = 6379 , db = 0 ) # toggle recording current = r . get ( 'is_recording' ) new_value = b '0' if current == b '1' else b '1' r . set ( 'is_recording' , new_value ) r . publish ( 'cp_controls' , 'is_recording' ) Note that in this example, the publishing of the is_recording key is not strictly needed for recording to start/stop, but for formality's sake I think we should keep the publish command. Info This is basically what Cinemate does: it keeps track of variables being set by cinepi-raw, and also sets variables itself.","title":"Redis API"},{"location":"redis-guide/#redis-api-quick-start","text":"","title":"Redis API quick start"},{"location":"redis-guide/#redis-cli","text":"# List all keys redis-cli KEYS '*' # Read the current ISO value redis-cli GET iso # Start a recording (same as pressing the Rec button) redis-cli SET is_recording 1 redis-cli PUBLISH cp_controls is_recording You can also type: redis-cli This will open the redis cli.","title":"Redis-cli"},{"location":"redis-guide/#cp_controls","text":"Both CinePi-raw and Cinemate writes values and immediately publish the key name. The recorder only reacts when it receives that publish event. Any key may be sent this way. For example, to adjust the preview zoom: # Set preview zoom level redis-cli SET zoom 1 .5 redis-cli PUBLISH cp_controls zoom Note that for the is_recording key Cinemate stops recording upon edge detection (the variable changes from 0 to 1 or vice versa). The reason for this exception has to do with how the CinePi-raw fork handles recording with multiple cameras # Start recording redis-cli SET is_recording 1 # triggers 0 \u2192 1 edge # Stop recording redis-cli SET is_recording 0 # triggers 1 \u2192 0 edge","title":"cp_controls"},{"location":"redis-guide/#cp_stats","text":"Every frame, cinepi-raw sends a small JSON object containing live statistics. Json :: Value data ; Json :: Value histo ; data [ \"framerate\" ] = completed_request -> framerate ; data [ \"colorTemp\" ] = info . colorTemp ; data [ \"focus\" ] = info . focus ; data [ \"frameCount\" ] = app_ -> GetEncoder () -> getFrameCount (); data [ \"bufferSize\" ] = app_ -> GetEncoder () -> bufferSize (); redis_ -> publish ( CHANNEL_STATS , data . toStyledString ()); CineMate\u2019s RedisListener parses these messages and updates Redis keys like framecount , BUFFER and fps_actual .","title":"cp_stats"},{"location":"redis-guide/#controlling-the-camera-from-your-own-script","text":"Below is a very small example using redis-py . import redis r = redis . Redis ( host = 'localhost' , port = 6379 , db = 0 ) # toggle recording current = r . get ( 'is_recording' ) new_value = b '0' if current == b '1' else b '1' r . set ( 'is_recording' , new_value ) r . publish ( 'cp_controls' , 'is_recording' ) Note that in this example, the publishing of the is_recording key is not strictly needed for recording to start/stop, but for formality's sake I think we should keep the publish command. Info This is basically what Cinemate does: it keeps track of variables being set by cinepi-raw, and also sets variables itself.","title":"Controlling the camera from your own script"},{"location":"redis-keys/","text":"Redis key reference # This page lists all Redis keys used by Cinemate and CinePi-raw. Values are simple strings so you can read or write them with redis-cli . Each entry explains which component normally writes the key and what happens when you change it manually. Key Written by Description Safe to change manually? anamorphic_factor Cinemate Preview squeeze for anamorphic lenses Yes (publish key to apply) iso Cinemate \u2192 CinePi-raw Sensor gain in ISO Yes shutter_a Cinemate \u2192 CinePi-raw Actual shutter angle in degrees Yes shutter_angle_nom Cinemate Desired shutter angle before sync/free adjustments Yes shutter_a_sync_mode Cinemate Keep exposure constant when changing FPS Yes fps Cinemate \u2192 CinePi-raw Target frames per second Yes sensor_mode Cinemate \u2192 CinePi-raw startup Active sensor resolution/mode Yes (causes pipeline restart) wb Cinemate \u2192 CinePi-raw White\u2011balance temperature (Kelvin) Yes zoom Cinemate Digital zoom for preview streams Yes ir_filter Cinemate \u2192 CinePi-raw Toggle IR\u2011cut filter (IMX585 only) Yes rec / is_recording Cinemate \u2192 CinePi-raw Start/stop recording when toggled Yes (edge\u2011triggered) bit_depth Cinemate \u2192 CinePi-raw startup Sensor bit depth (10 or 12) No (set at startup) height / width Cinemate \u2192 CinePi-raw startup Active sensor resolution No lores_width / lores_height CinePi-raw startup Preview stream resolution No cg_rb Cinemate \u2192 CinePi-raw White\u2011balance gain pair \"1/R,1/B\" Yes (advanced) fps_user Cinemate Temporary storage for the UI slider No fps_last Cinemate Previous stable fps from stats No fps_actual CinePi-raw \u2192 Cinemate Measured FPS from pipeline No framecount CinePi-raw \u2192 Cinemate Total frames recorded No buffer CinePi-raw \u2192 Cinemate Raw frames currently in RAM No buffer_size CinePi-raw \u2192 Cinemate Size of RAM buffer in frames No is_buffering CinePi-raw \u2192 Cinemate 1 while buffer pre\u2011fills No is_writing CinePi-raw \u2192 Cinemate 1 while frames are flushing to disk No is_writing_buf Cinemate Internal countdown after recording stops No is_mounted Cinemate (SSD monitor) 1 when storage is mounted No storage_type Cinemate (SSD monitor) Drive type (NVME/USB/SD) No space_left Cinemate (SSD monitor) Remaining space in GB No write_speed_to_drive Cinemate (SSD monitor) Current write speed MB/s No file_size Cinemate Bytes per frame for current mode No last_dng_cam0/1 CinePi-raw \u2192 Cinemate Path to last written DNG frame No recording_time Cinemate HH:MM:SS:FF timer while recording No memory_alert Cinemate 1 if RAM usage high No cam_init CinePi-raw Internal flag during startup No cameras CinePi-raw JSON list of detected cameras No gui_layout Cinemate Path to GUI layout preset No pi_model Cinemate Raspberry Pi model string No sensor CinePi-raw Active camera model No tc_cam0/tc_cam1 CinePi-raw \u2192 Cinemate SMPTE time code per camera No shutter_angle_actual Cinemate Calculated shutter angle applied after clamping or sync No shutter_angle_transient Cinemate Temporary value during ramping No exposure_time Cinemate Current exposure time in seconds No wb_user Cinemate Kelvin value set before converting to cg_rb No","title":"Key reference"},{"location":"redis-keys/#redis-key-reference","text":"This page lists all Redis keys used by Cinemate and CinePi-raw. Values are simple strings so you can read or write them with redis-cli . Each entry explains which component normally writes the key and what happens when you change it manually. Key Written by Description Safe to change manually? anamorphic_factor Cinemate Preview squeeze for anamorphic lenses Yes (publish key to apply) iso Cinemate \u2192 CinePi-raw Sensor gain in ISO Yes shutter_a Cinemate \u2192 CinePi-raw Actual shutter angle in degrees Yes shutter_angle_nom Cinemate Desired shutter angle before sync/free adjustments Yes shutter_a_sync_mode Cinemate Keep exposure constant when changing FPS Yes fps Cinemate \u2192 CinePi-raw Target frames per second Yes sensor_mode Cinemate \u2192 CinePi-raw startup Active sensor resolution/mode Yes (causes pipeline restart) wb Cinemate \u2192 CinePi-raw White\u2011balance temperature (Kelvin) Yes zoom Cinemate Digital zoom for preview streams Yes ir_filter Cinemate \u2192 CinePi-raw Toggle IR\u2011cut filter (IMX585 only) Yes rec / is_recording Cinemate \u2192 CinePi-raw Start/stop recording when toggled Yes (edge\u2011triggered) bit_depth Cinemate \u2192 CinePi-raw startup Sensor bit depth (10 or 12) No (set at startup) height / width Cinemate \u2192 CinePi-raw startup Active sensor resolution No lores_width / lores_height CinePi-raw startup Preview stream resolution No cg_rb Cinemate \u2192 CinePi-raw White\u2011balance gain pair \"1/R,1/B\" Yes (advanced) fps_user Cinemate Temporary storage for the UI slider No fps_last Cinemate Previous stable fps from stats No fps_actual CinePi-raw \u2192 Cinemate Measured FPS from pipeline No framecount CinePi-raw \u2192 Cinemate Total frames recorded No buffer CinePi-raw \u2192 Cinemate Raw frames currently in RAM No buffer_size CinePi-raw \u2192 Cinemate Size of RAM buffer in frames No is_buffering CinePi-raw \u2192 Cinemate 1 while buffer pre\u2011fills No is_writing CinePi-raw \u2192 Cinemate 1 while frames are flushing to disk No is_writing_buf Cinemate Internal countdown after recording stops No is_mounted Cinemate (SSD monitor) 1 when storage is mounted No storage_type Cinemate (SSD monitor) Drive type (NVME/USB/SD) No space_left Cinemate (SSD monitor) Remaining space in GB No write_speed_to_drive Cinemate (SSD monitor) Current write speed MB/s No file_size Cinemate Bytes per frame for current mode No last_dng_cam0/1 CinePi-raw \u2192 Cinemate Path to last written DNG frame No recording_time Cinemate HH:MM:SS:FF timer while recording No memory_alert Cinemate 1 if RAM usage high No cam_init CinePi-raw Internal flag during startup No cameras CinePi-raw JSON list of detected cameras No gui_layout Cinemate Path to GUI layout preset No pi_model Cinemate Raspberry Pi model string No sensor CinePi-raw Active camera model No tc_cam0/tc_cam1 CinePi-raw \u2192 Cinemate SMPTE time code per camera No shutter_angle_actual Cinemate Calculated shutter angle applied after clamping or sync No shutter_angle_transient Cinemate Temporary value during ramping No exposure_time Cinemate Current exposure time in seconds No wb_user Cinemate Kelvin value set before converting to cg_rb No","title":"Redis key reference"},{"location":"sensor.sizes/","text":"Image circles and sensor sizes # What do \u201c1 inch\u201d and \u201c1/2.3 inch\u201d actually mean? # Those fractions are legacy video\u2011tube designations and not the physical diagonal of the sensor. For example: Marketing name Actual diagonal Typical crop factor* \u201cFull\u2011frame\u201d (35\u202fmm stills) 43\u202fmm 1.0\u00d7 (reference) Micro\u2011Four\u2011Thirds 22\u202fmm ~2.0\u00d7 \u201c1 inch\u201d 16\u202fmm ~2.7\u00d7 Raspberry\u202fPi\u202fHQ (IMX477, sold as \u201c1/2.3 inch\u201d) 7.9\u202fmm ~5.6\u00d7 As we can see, the smaller the sensor the larger the crop factor with regards to the 35mm standard reference. C/CS Mounts C and CS lenses were designed for small\u2011format video and security cameras, so their image circles perfectly cover the IMX477. The Raspberry\u202fPi HQ board also has a built\u2011in back\u2011focus adjustment 4 What if I really want wide shots? # You have two realistic options: Speed\u2011boosters and focal reducers These compress a larger image circle down onto the small sensor, regaining some angle of view. They cost more than the camera and introduce extra optical surfaces, but can work in a pinch. A bigger sensor Stepping up to something like the IMX585 (\u201c1/1.2 inch\u201d) cuts the crop factor roughly in half. At that point, adapting Micro\u2011Four\u2011Thirds or vintage 35\u202fmm lenses begins to make practical sense. 5 Buying roadmap for beginners # Start with the stock 6\u202f\u2013\u202f12\u202fmm Raspberry\u202fPi zoom It teaches you which focal lengths you genuinely use. Add one or two vintage C\u2011mount primes Look for 8\u202fmm or 12\u202fmm lenses from brands such as Kern\u2011Paillard, Computar, or Ang\u00e9nieux. They\u2019re small, sharp, and often under \u20ac100. Master back\u2011focus adjustment The HQ board\u2019s silver ring lets you dial in infinity focus without spacers\u2014a lifesaver when swapping lenses. Only then consider adapters If you\u2019re bumping into the limits of the sensor rather than the lens, that\u2019s the signal to explore larger sensors like the IMX585 plus an MFT or EF adapter. 6 Rules of thumb (bookmark these) # Focal length math: Effective 35\u202fmm focal length = Lens focal length \u00d7 Crop factor . (e.g., 12\u202fmm \u00d7 5.6 \u2248 67\u202fmm portrait.) Image circle > sensor diagonal. If the spec sheet doesn\u2019t list it, assume C/CS lenses cover up to 11\u202fmm and nothing larger. Big\u2011sensor lenses on tiny sensors \u2260 better image. Quality comes from glass matched to the sensor, not size alone. TL;DR # For the Raspberry\u202fPi HQ camera (IMX477), vintage C\u2011mount lenses are your best friends \u2014they cover the sensor perfectly, cost little, and keep the rig small. If you crave a wider field of view or shallower depth of field that feels \u201ccinematic,\u201d consider upgrading the sensor itself (e.g., IMX585) before chasing exotic adapters and full\u2011frame glass. Happy shooting, and may your pixels always land exactly where you intend!","title":"Image circles and sensor sizes"},{"location":"sensor.sizes/#image-circles-and-sensor-sizes","text":"","title":"Image circles and sensor sizes"},{"location":"sensor.sizes/#what-do-1-inch-and-123-inch-actually-mean","text":"Those fractions are legacy video\u2011tube designations and not the physical diagonal of the sensor. For example: Marketing name Actual diagonal Typical crop factor* \u201cFull\u2011frame\u201d (35\u202fmm stills) 43\u202fmm 1.0\u00d7 (reference) Micro\u2011Four\u2011Thirds 22\u202fmm ~2.0\u00d7 \u201c1 inch\u201d 16\u202fmm ~2.7\u00d7 Raspberry\u202fPi\u202fHQ (IMX477, sold as \u201c1/2.3 inch\u201d) 7.9\u202fmm ~5.6\u00d7 As we can see, the smaller the sensor the larger the crop factor with regards to the 35mm standard reference. C/CS Mounts C and CS lenses were designed for small\u2011format video and security cameras, so their image circles perfectly cover the IMX477. The Raspberry\u202fPi HQ board also has a built\u2011in back\u2011focus adjustment","title":"What do \u201c1 inch\u201d and \u201c1/2.3 inch\u201d actually mean?"},{"location":"sensor.sizes/#4-what-if-i-really-want-wide-shots","text":"You have two realistic options: Speed\u2011boosters and focal reducers These compress a larger image circle down onto the small sensor, regaining some angle of view. They cost more than the camera and introduce extra optical surfaces, but can work in a pinch. A bigger sensor Stepping up to something like the IMX585 (\u201c1/1.2 inch\u201d) cuts the crop factor roughly in half. At that point, adapting Micro\u2011Four\u2011Thirds or vintage 35\u202fmm lenses begins to make practical sense.","title":"4 What if I really want wide shots?"},{"location":"sensor.sizes/#5-buying-roadmap-for-beginners","text":"Start with the stock 6\u202f\u2013\u202f12\u202fmm Raspberry\u202fPi zoom It teaches you which focal lengths you genuinely use. Add one or two vintage C\u2011mount primes Look for 8\u202fmm or 12\u202fmm lenses from brands such as Kern\u2011Paillard, Computar, or Ang\u00e9nieux. They\u2019re small, sharp, and often under \u20ac100. Master back\u2011focus adjustment The HQ board\u2019s silver ring lets you dial in infinity focus without spacers\u2014a lifesaver when swapping lenses. Only then consider adapters If you\u2019re bumping into the limits of the sensor rather than the lens, that\u2019s the signal to explore larger sensors like the IMX585 plus an MFT or EF adapter.","title":"5 Buying roadmap for beginners"},{"location":"sensor.sizes/#6-rules-of-thumb-bookmark-these","text":"Focal length math: Effective 35\u202fmm focal length = Lens focal length \u00d7 Crop factor . (e.g., 12\u202fmm \u00d7 5.6 \u2248 67\u202fmm portrait.) Image circle > sensor diagonal. If the spec sheet doesn\u2019t list it, assume C/CS lenses cover up to 11\u202fmm and nothing larger. Big\u2011sensor lenses on tiny sensors \u2260 better image. Quality comes from glass matched to the sensor, not size alone.","title":"6 Rules of thumb (bookmark these)"},{"location":"sensor.sizes/#tldr","text":"For the Raspberry\u202fPi HQ camera (IMX477), vintage C\u2011mount lenses are your best friends \u2014they cover the sensor perfectly, cost little, and keep the rig small. If you crave a wider field of view or shallower depth of field that feels \u201ccinematic,\u201d consider upgrading the sensor itself (e.g., IMX585) before chasing exotic adapters and full\u2011frame glass. Happy shooting, and may your pixels always land exactly where you intend!","title":"TL;DR"},{"location":"sensors/","text":"Compatible sensors # Sensor Cinemate sensor mode Resolution Aspect Ratio Bit Depth Max FPS* File Size (MB) IMX283 0 2736 x 1538 1.80 12 40 7.1 1 2736 x 1824 1.53 12 34 8.2 IMX296 0 1456 x 1088 1.33 12 60 2 IMX477 0 2028 x 1080 1.87 12 50 4.3 1 2028 x 1520 1.33 12 40 5.3 2 1332 x 990 1.34 10 120 2.7 IMX585 0 1928 x 1090 1.77 12 87 4 1 3840 x 2160 1.77 12 34 4 Note that maximum fps will vary according to disk write speed. For the specific fps values for your setup, make test recordings and monitor the output. Purple background in the monitor/web browser indicates drop frames. You can cap Cinemates max fps values for your specific build by editing the file cinemate/src/module/sensor_detect.py","title":"Sensors"},{"location":"sensors/#compatible-sensors","text":"Sensor Cinemate sensor mode Resolution Aspect Ratio Bit Depth Max FPS* File Size (MB) IMX283 0 2736 x 1538 1.80 12 40 7.1 1 2736 x 1824 1.53 12 34 8.2 IMX296 0 1456 x 1088 1.33 12 60 2 IMX477 0 2028 x 1080 1.87 12 50 4.3 1 2028 x 1520 1.33 12 40 5.3 2 1332 x 990 1.34 10 120 2.7 IMX585 0 1928 x 1090 1.77 12 87 4 1 3840 x 2160 1.77 12 34 4 Note that maximum fps will vary according to disk write speed. For the specific fps values for your setup, make test recordings and monitor the output. Purple background in the monitor/web browser indicates drop frames. You can cap Cinemates max fps values for your specific build by editing the file cinemate/src/module/sensor_detect.py","title":"Compatible sensors"},{"location":"settings-json/","text":"Settings file # This file controls how the camera behaves and how your buttons, switches and displays are mapped. It lives in ~/cinemate/src/settings.json on the Raspberry Pi. You can edit it with any text editor; the settings take effect the next time you start CineMate. The configuration is structured as JSON. Each top\u2011level key describes a feature area of the system. Below is a tour of every section and what the options do. welcome message # Text or image displayed briefly when Cinemate starts. \"welcome_image\" : null \"welcome_message\" : \"THIS IS A COOL MACHINE\" , Set welcome_image to the path of a bitmap file to show a logo instead of text. Example path: /home/pi/welcome_image.bmp . If welcome image path is set, this will override the text message. system # \"system\" : { \"wifi_hotspot\" : { \"name\" : \"CinePi\" , \"password\" : \"11111111\" , \"enabled\" : false } } name \u2013 the Wi\u2011Fi network name (SSID) broadcast by the Pi when hotspot mode is enabled. password \u2013 password for joining the hotspot. enabled \u2013 set to true to start the hotspot automatically on boot. If set to false , CineMate will still start its web ui but stream it on whatever network the Pi is connected to. Use the hotspot when you need a direct connection in the field. Disable it during development so the Pi can join your regular Wi\u2011Fi and reach the internet. If you are connected to the Pi via Ethernet you can keep the hotspot on. geometry # Controls image orientation for each camera port ( cam0 , cam1 , etc.). These settings let you mount cameras in any orientation and still get an upright preview and recording. Example: \"geometry\" : { \"cam0\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false }, \"cam1\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false } } rotate_180 \u2013 flip the image upside\u2011down. horizontal_flip \u2013 mirror the image left/right. vertical_flip \u2013 mirror the image top/bottom. output # Maps each camera to an HDMI connector. Use -1 for automatic selection. \"output\" : { \"cam0\" : { \"hdmi_port\" : 0 }, \"cam1\" : { \"hdmi_port\" : 1 } } preview # Adjusts zoom levels for the HDMI/browser preview. \"preview\" : { \"default_zoom\" : 1.0 , \"zoom_steps\" : [ 1.0 , 1.5 , 2.0 ] } default_zoom \u2013 magnification factor used at startup. zoom_steps \u2013 list of zoom factors you can cycle through with the set_zoom_step command. anamorphic_preview # For stretching the preview when using anamorphic lenses. \"anamorphic_preview\" : { \"default_anamorphic_factor\" : 1 , \"anamorphic_steps\" : [ 1 , 1.33 , 2.0 ] } default_anamorphic_factor \u2013 factor loaded when Cinemate starts. anamorphic_steps \u2013 selectable squeeze factors; values above 1.0 widen the image. gpio_output # Defines pins used for visual feedback or sync signals. \"gpio_output\" : { \"pwm_pin\" : 19 , \"rec_out_pin\" : [ 6 , 21 ] } pwm_pin \u2013 outputs a strobe for shutter sync or external devices. rec_out_pin \u2013 list of pins pulled high while recording (useful for tally LEDs). arrays # Preset lists for exposure and frame\u2011rate settings. Cinemate will step through these values unless you enable free mode, either in the settings file or during runtime. \"arrays\" : { \"iso_steps\" : [ 100 , 200 , 400 , 640 , 800 , 1200 , 1600 , 2500 , 3200 ], \"shutter_a_steps\" : [ 1 , 45 , 90 , 135 , 172.8 , 180 , 225 , 270 , 315 , 346.6 , 360 ], \"fps_steps\" : [ 1 , 2 , 4 , 8 , 12 , 16 , 18 , 24 , 25 , 33 , 40 , 50 ], \"wb_steps\" : [ 3200 , 4400 , 5600 ] } settings # General options for runtime behaviour. \"settings\" : { \"light_hz\" : [ 50 , 60 ], \"conform_frame_rate\" : 24 } light_hz \u2013 list of mains frequencies used to calculate flicker\u2011free shutter angles. These are added to the shutter angle array and also dynamically calculated upon each fps change. This way, there is always a flicker free shutter angle value close by, when toggling through shutter angles, either via the cli or using buttons/pots/rotary encoder. conform_frame_rate \u2013 frame rate intendend for project conforming in post. This setting is not really used by CineMate except for calculating the recording timecode tracker in redis but might be used in future updates. analog_controls # Maps Grove Base HAT ADC channels to analogue dials (potentiometers). Use null to disable a dial. \"analog_controls\" : { \"iso_pot\" : 0 , \"shutter_a_pot\" : 2 , \"fps_pot\" : 4 , \"wb_pot\" : 6 } Note that even if you are using a Grove Base Hat, it might be useful to disable the dials not connected to pots, since noise from these connectors might trigger false readings. free_mode # When enabled, ignores the preset arrays and exposes the full range supported by the sensor. \"free_mode\" : { \"iso_free\" : false , \"shutter_a_free\" : false , \"fps_free\" : true , \"wb_free\" : false } buttons # Defines GPIO push buttons. Each entry describes one button and the actions it triggers. { \"pin\" : 5 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"rec\" } } pin \u2013 BCM pin number the button is connected to. pull_up \u2013 set true if the pin idles high (internal pull\u2011up). Use false for pull\u2011down wiring. debounce_time \u2013 ignore additional presses within this time window (seconds). press_action , single_click_action , double_click_action , triple_click_action , hold_action \u2013 actions to perform for each type of interaction. Actions call Cinemate CLI commands with optional args . Automatic detection of inverse push buttons Some push-buttons are wired closed = logic 1 and open = 0. At start-up, CineMate automatically detects buttons in state true and reverses them. This way the user can use any type of push buttons, both 1-0-1 and 0-1-0 types. two_way_switches # Latching on/off switches. Cinemate triggers an action whenever the state changes. { \"pin\" : 27 , \"state_on_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 1 ]}, \"state_off_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 0 ]} } rotary_encoders # Rotary encoders used for fine adjustment of settings. These can be wired straight to the GPIO pins of the Pi. { \"clk_pin\" : 9 , \"dt_pin\" : 11 , \"encoder_actions\" : { \"rotate_clockwise\" : { \"method\" : \"inc_iso\" }, \"rotate_counterclockwise\" : { \"method\" : \"dec_iso\" } } } clk_pin and dt_pin \u2013 the two pins of the encoder. encoder_actions \u2013 commands to run when turning the dial. quad_rotary_controller # Support for the Adafruit Neopixel Quad I2C rotary encoder breakout. Each entry maps one of the four dials to a setting and defines the push button actions similar to the buttons section. \"quad_rotary_controller\" : { \"enabled\" : true , \"encoders\" : { \"0\" : { \"setting_name\" : \"iso\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}}, \"1\" : { \"setting_name\" : \"shutter_a\" , \"button\" : { \"press_action\" : { \"method\" : \"set_fps_double\" }}}, \"2\" : { \"setting_name\" : \"fps\" , \"button\" : { \"press_action\" : \"None\" , \"single_click_action\" : { \"method\" : \"set_resolution\" }, \"double_click_action\" : { \"method\" : \"restart_cinemate\" }, \"triple_click_action\" : { \"method\" : \"reboot\" }, \"hold_action\" : { \"method\" : \"toggle_mount\" } } }, \"3\" : { \"setting_name\" : \"wb\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}} } } enabled \u2013 turn the quad rotary controller on or off. encoders \u2013 mapping of each dial to a setting and button actions. i2c_oled # Configuration for the optional OLED status screen. This can be useful for presenting extra information appart from the HDMI/web display. \"i2c_oled\" : { \"enabled\" : true , \"width\" : 128 , \"height\" : 64 , \"font_size\" : 30 , \"values\" : [ \"write_speed_to_drive\" ] } enabled \u2013 turn the OLED display on or off. width / height \u2013 pixel dimensions of your screen. font_size \u2013 size of the displayed text. values \u2013 list of Redis keys or pseudo\u2011keys to show (for example cpu_temp ). Available keys come from src/module/i2c/i2c_oled.py . Here are some examples: iso , fps \u2013 basic camera settings. shutter_a \u2013 shown as SHUTTER with a \u00b0 suffix. wb_user \u2013 shown as WB with a trailing K . space_left \u2013 displayed as SPACE in gigabytes. write_speed_to_drive \u2013 write speed in MB/s. resolution \u2013 prints width\u00d7height@bit_depth on the first line. is_recording \u2013 draws a bullet \u25cf when recording. cpu_load , cpu_temp , memory_usage \u2013 Pi system statistics. Other keys will display their name in uppercase and the raw value from Redis.","title":"Settings file"},{"location":"settings-json/#settings-file","text":"This file controls how the camera behaves and how your buttons, switches and displays are mapped. It lives in ~/cinemate/src/settings.json on the Raspberry Pi. You can edit it with any text editor; the settings take effect the next time you start CineMate. The configuration is structured as JSON. Each top\u2011level key describes a feature area of the system. Below is a tour of every section and what the options do.","title":"Settings file"},{"location":"settings-json/#welcome-message","text":"Text or image displayed briefly when Cinemate starts. \"welcome_image\" : null \"welcome_message\" : \"THIS IS A COOL MACHINE\" , Set welcome_image to the path of a bitmap file to show a logo instead of text. Example path: /home/pi/welcome_image.bmp . If welcome image path is set, this will override the text message.","title":"welcome message"},{"location":"settings-json/#system","text":"\"system\" : { \"wifi_hotspot\" : { \"name\" : \"CinePi\" , \"password\" : \"11111111\" , \"enabled\" : false } } name \u2013 the Wi\u2011Fi network name (SSID) broadcast by the Pi when hotspot mode is enabled. password \u2013 password for joining the hotspot. enabled \u2013 set to true to start the hotspot automatically on boot. If set to false , CineMate will still start its web ui but stream it on whatever network the Pi is connected to. Use the hotspot when you need a direct connection in the field. Disable it during development so the Pi can join your regular Wi\u2011Fi and reach the internet. If you are connected to the Pi via Ethernet you can keep the hotspot on.","title":"system"},{"location":"settings-json/#geometry","text":"Controls image orientation for each camera port ( cam0 , cam1 , etc.). These settings let you mount cameras in any orientation and still get an upright preview and recording. Example: \"geometry\" : { \"cam0\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false }, \"cam1\" : { \"rotate_180\" : false , \"horizontal_flip\" : false , \"vertical_flip\" : false } } rotate_180 \u2013 flip the image upside\u2011down. horizontal_flip \u2013 mirror the image left/right. vertical_flip \u2013 mirror the image top/bottom.","title":"geometry"},{"location":"settings-json/#output","text":"Maps each camera to an HDMI connector. Use -1 for automatic selection. \"output\" : { \"cam0\" : { \"hdmi_port\" : 0 }, \"cam1\" : { \"hdmi_port\" : 1 } }","title":"output"},{"location":"settings-json/#preview","text":"Adjusts zoom levels for the HDMI/browser preview. \"preview\" : { \"default_zoom\" : 1.0 , \"zoom_steps\" : [ 1.0 , 1.5 , 2.0 ] } default_zoom \u2013 magnification factor used at startup. zoom_steps \u2013 list of zoom factors you can cycle through with the set_zoom_step command.","title":"preview"},{"location":"settings-json/#anamorphic_preview","text":"For stretching the preview when using anamorphic lenses. \"anamorphic_preview\" : { \"default_anamorphic_factor\" : 1 , \"anamorphic_steps\" : [ 1 , 1.33 , 2.0 ] } default_anamorphic_factor \u2013 factor loaded when Cinemate starts. anamorphic_steps \u2013 selectable squeeze factors; values above 1.0 widen the image.","title":"anamorphic_preview"},{"location":"settings-json/#gpio_output","text":"Defines pins used for visual feedback or sync signals. \"gpio_output\" : { \"pwm_pin\" : 19 , \"rec_out_pin\" : [ 6 , 21 ] } pwm_pin \u2013 outputs a strobe for shutter sync or external devices. rec_out_pin \u2013 list of pins pulled high while recording (useful for tally LEDs).","title":"gpio_output"},{"location":"settings-json/#arrays","text":"Preset lists for exposure and frame\u2011rate settings. Cinemate will step through these values unless you enable free mode, either in the settings file or during runtime. \"arrays\" : { \"iso_steps\" : [ 100 , 200 , 400 , 640 , 800 , 1200 , 1600 , 2500 , 3200 ], \"shutter_a_steps\" : [ 1 , 45 , 90 , 135 , 172.8 , 180 , 225 , 270 , 315 , 346.6 , 360 ], \"fps_steps\" : [ 1 , 2 , 4 , 8 , 12 , 16 , 18 , 24 , 25 , 33 , 40 , 50 ], \"wb_steps\" : [ 3200 , 4400 , 5600 ] }","title":"arrays"},{"location":"settings-json/#settings","text":"General options for runtime behaviour. \"settings\" : { \"light_hz\" : [ 50 , 60 ], \"conform_frame_rate\" : 24 } light_hz \u2013 list of mains frequencies used to calculate flicker\u2011free shutter angles. These are added to the shutter angle array and also dynamically calculated upon each fps change. This way, there is always a flicker free shutter angle value close by, when toggling through shutter angles, either via the cli or using buttons/pots/rotary encoder. conform_frame_rate \u2013 frame rate intendend for project conforming in post. This setting is not really used by CineMate except for calculating the recording timecode tracker in redis but might be used in future updates.","title":"settings"},{"location":"settings-json/#analog_controls","text":"Maps Grove Base HAT ADC channels to analogue dials (potentiometers). Use null to disable a dial. \"analog_controls\" : { \"iso_pot\" : 0 , \"shutter_a_pot\" : 2 , \"fps_pot\" : 4 , \"wb_pot\" : 6 } Note that even if you are using a Grove Base Hat, it might be useful to disable the dials not connected to pots, since noise from these connectors might trigger false readings.","title":"analog_controls"},{"location":"settings-json/#free_mode","text":"When enabled, ignores the preset arrays and exposes the full range supported by the sensor. \"free_mode\" : { \"iso_free\" : false , \"shutter_a_free\" : false , \"fps_free\" : true , \"wb_free\" : false }","title":"free_mode"},{"location":"settings-json/#buttons","text":"Defines GPIO push buttons. Each entry describes one button and the actions it triggers. { \"pin\" : 5 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"rec\" } } pin \u2013 BCM pin number the button is connected to. pull_up \u2013 set true if the pin idles high (internal pull\u2011up). Use false for pull\u2011down wiring. debounce_time \u2013 ignore additional presses within this time window (seconds). press_action , single_click_action , double_click_action , triple_click_action , hold_action \u2013 actions to perform for each type of interaction. Actions call Cinemate CLI commands with optional args . Automatic detection of inverse push buttons Some push-buttons are wired closed = logic 1 and open = 0. At start-up, CineMate automatically detects buttons in state true and reverses them. This way the user can use any type of push buttons, both 1-0-1 and 0-1-0 types.","title":"buttons"},{"location":"settings-json/#two_way_switches","text":"Latching on/off switches. Cinemate triggers an action whenever the state changes. { \"pin\" : 27 , \"state_on_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 1 ]}, \"state_off_action\" : { \"method\" : \"set_all_lock\" , \"args\" : [ 0 ]} }","title":"two_way_switches"},{"location":"settings-json/#rotary_encoders","text":"Rotary encoders used for fine adjustment of settings. These can be wired straight to the GPIO pins of the Pi. { \"clk_pin\" : 9 , \"dt_pin\" : 11 , \"encoder_actions\" : { \"rotate_clockwise\" : { \"method\" : \"inc_iso\" }, \"rotate_counterclockwise\" : { \"method\" : \"dec_iso\" } } } clk_pin and dt_pin \u2013 the two pins of the encoder. encoder_actions \u2013 commands to run when turning the dial.","title":"rotary_encoders"},{"location":"settings-json/#quad_rotary_controller","text":"Support for the Adafruit Neopixel Quad I2C rotary encoder breakout. Each entry maps one of the four dials to a setting and defines the push button actions similar to the buttons section. \"quad_rotary_controller\" : { \"enabled\" : true , \"encoders\" : { \"0\" : { \"setting_name\" : \"iso\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}}, \"1\" : { \"setting_name\" : \"shutter_a\" , \"button\" : { \"press_action\" : { \"method\" : \"set_fps_double\" }}}, \"2\" : { \"setting_name\" : \"fps\" , \"button\" : { \"press_action\" : \"None\" , \"single_click_action\" : { \"method\" : \"set_resolution\" }, \"double_click_action\" : { \"method\" : \"restart_cinemate\" }, \"triple_click_action\" : { \"method\" : \"reboot\" }, \"hold_action\" : { \"method\" : \"toggle_mount\" } } }, \"3\" : { \"setting_name\" : \"wb\" , \"button\" : { \"press_action\" : { \"method\" : \"rec\" }}} } } enabled \u2013 turn the quad rotary controller on or off. encoders \u2013 mapping of each dial to a setting and button actions.","title":"quad_rotary_controller"},{"location":"settings-json/#i2c_oled","text":"Configuration for the optional OLED status screen. This can be useful for presenting extra information appart from the HDMI/web display. \"i2c_oled\" : { \"enabled\" : true , \"width\" : 128 , \"height\" : 64 , \"font_size\" : 30 , \"values\" : [ \"write_speed_to_drive\" ] } enabled \u2013 turn the OLED display on or off. width / height \u2013 pixel dimensions of your screen. font_size \u2013 size of the displayed text. values \u2013 list of Redis keys or pseudo\u2011keys to show (for example cpu_temp ). Available keys come from src/module/i2c/i2c_oled.py . Here are some examples: iso , fps \u2013 basic camera settings. shutter_a \u2013 shown as SHUTTER with a \u00b0 suffix. wb_user \u2013 shown as WB with a trailing K . space_left \u2013 displayed as SPACE in gigabytes. write_speed_to_drive \u2013 write speed in MB/s. resolution \u2013 prints width\u00d7height@bit_depth on the first line. is_recording \u2013 draws a bullet \u25cf when recording. cpu_load , cpu_temp , memory_usage \u2013 Pi system statistics. Other keys will display their name in uppercase and the raw value from Redis.","title":"i2c_oled"},{"location":"simple-gui/","text":"Simple GUI # Simple GUI is available via browser and/or attached HDMI monitor. Red color means camera is recording. Purple color means camera detected a drop frame Green color means camera is writing buffered frames to disk. You can still start recording at this stage, but any buffered frames from the last recording will be lost. Buffer meter in the lower left indicates number of frames in buffer. Useful when testing storage media. When a compatible USB microphone is connected, VU meters appear on the right side of the GUI so you can monitor audio levels.","title":"HDMI GUI"},{"location":"simple-gui/#simple-gui","text":"Simple GUI is available via browser and/or attached HDMI monitor. Red color means camera is recording. Purple color means camera detected a drop frame Green color means camera is writing buffered frames to disk. You can still start recording at this stage, but any buffered frames from the last recording will be lost. Buffer meter in the lower left indicates number of frames in buffer. Useful when testing storage media. When a compatible USB microphone is connected, VU meters appear on the right side of the GUI so you can monitor audio levels.","title":"Simple GUI"},{"location":"speed-ramping/","text":"Speed ramping # Speed ramping is the process of changing the camera's frame rate during a shot so that playback speed varies once the footage is conformed to a constant frame rate in post production. Ramping up the frame rate produces slow motion while ramping down speeds up the action. Speed ramping in Cinemate # Cinemate exposes frame rate control through the CinePiController class. The simplest way to change speed on the fly is the CLI command: set fps <value> For quick 2\u00d7 changes Cinemate also implements set_fps_double which toggles between the current FPS and twice that value. This can be used for designing a slow-motion button. Here is how you would to it in the settings file, button section: { \"pin\" : 18 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"set_fps_double\" } } No argument is needed here. For methods such as set_fps_double , calling the method without an argument will simply toggle the control, in tis caseturning the slow motion on and off. If the user provides an argument, the control will be set explicitly to that value. The controller contains an experimental _ramp_fps helper that gradually steps the frame rate up or down using ramp_up_speed and ramp_down_speed delays. This can be adapted if smoother transitions are desired. Shutter angle synchronisation # When frame rate changes the shutter angle can either remain fixed (preserving motion blur) or adjust to keep the exposure time constant. This behaviour is controlled by shutter_a_sync_mode . Mode 0 keeps the motion blur consistent because the physical shutter angle does not change. As the FPS increases the exposure time gets shorter, resulting in a darker image. Mode 1 stores the current exposure time and recalculates the shutter angle whenever the FPS is adjusted so that exposure time stays the same. Cinemate updates the nominal exposure time when the user sets a new angle. FPS is recalculated from the stored exposure time:","title":"Speed ramping & shutter angle synchronization"},{"location":"speed-ramping/#speed-ramping","text":"Speed ramping is the process of changing the camera's frame rate during a shot so that playback speed varies once the footage is conformed to a constant frame rate in post production. Ramping up the frame rate produces slow motion while ramping down speeds up the action.","title":"Speed ramping"},{"location":"speed-ramping/#speed-ramping-in-cinemate","text":"Cinemate exposes frame rate control through the CinePiController class. The simplest way to change speed on the fly is the CLI command: set fps <value> For quick 2\u00d7 changes Cinemate also implements set_fps_double which toggles between the current FPS and twice that value. This can be used for designing a slow-motion button. Here is how you would to it in the settings file, button section: { \"pin\" : 18 , \"pull_up\" : true , \"debounce_time\" : 0.1 , \"press_action\" : { \"method\" : \"set_fps_double\" } } No argument is needed here. For methods such as set_fps_double , calling the method without an argument will simply toggle the control, in tis caseturning the slow motion on and off. If the user provides an argument, the control will be set explicitly to that value. The controller contains an experimental _ramp_fps helper that gradually steps the frame rate up or down using ramp_up_speed and ramp_down_speed delays. This can be adapted if smoother transitions are desired.","title":"Speed ramping in Cinemate"},{"location":"speed-ramping/#shutter-angle-synchronisation","text":"When frame rate changes the shutter angle can either remain fixed (preserving motion blur) or adjust to keep the exposure time constant. This behaviour is controlled by shutter_a_sync_mode . Mode 0 keeps the motion blur consistent because the physical shutter angle does not change. As the FPS increases the exposure time gets shorter, resulting in a darker image. Mode 1 stores the current exposure time and recalculates the shutter angle whenever the FPS is adjusted so that exposure time stays the same. Cinemate updates the nominal exposure time when the user sets a new angle. FPS is recalculated from the stored exposure time:","title":"Shutter angle synchronisation"},{"location":"ssh/","text":"Connecting to the Pi with SSH # Connect your computer and the Pi to the same network. If you are using the preinstalled image file, the system automatically starts a built-in hotspot: join the CinePi Wi\u2011Fi with password 11111111 . You can change this behaviour later in the settings file. Open a terminal (on Windows you can use PowerShell). Try the hostname first: ssh pi@cinepi.local If this fails you can list devices on the network: arp -a Look for an entry labelled cinepi or note the new IP address that appears. Use the hostname or IP address with SSH: ssh pi@cinepi.local # or ssh pi@<ip-address> When asked about the host key, type yes . Enter the default password 1 when prompted. You will now see the pi@cinepi prompt, meaning you are logged in. If you are installing Cinemate manually, the hostname has not yet been set to cinepi. Then you will have to identify which ip address on the network is actually the Raspberry Pi and use that ip address. From here you can run cinemate to start the interface or use make commands to manage the service. For security you should change the password with passwd after the first login.","title":"Connecting via SSH"},{"location":"ssh/#connecting-to-the-pi-with-ssh","text":"Connect your computer and the Pi to the same network. If you are using the preinstalled image file, the system automatically starts a built-in hotspot: join the CinePi Wi\u2011Fi with password 11111111 . You can change this behaviour later in the settings file. Open a terminal (on Windows you can use PowerShell). Try the hostname first: ssh pi@cinepi.local If this fails you can list devices on the network: arp -a Look for an entry labelled cinepi or note the new IP address that appears. Use the hostname or IP address with SSH: ssh pi@cinepi.local # or ssh pi@<ip-address> When asked about the host key, type yes . Enter the default password 1 when prompted. You will now see the pi@cinepi prompt, meaning you are logged in. If you are installing Cinemate manually, the hostname has not yet been set to cinepi. Then you will have to identify which ip address on the network is actually the Raspberry Pi and use that ip address. From here you can run cinemate to start the interface or use make commands to manage the service. For security you should change the password with passwd after the first login.","title":"Connecting to the Pi with SSH"},{"location":"system-services/","text":"System services # cinemate-autostart.service # make install # copy service file make enable # start on boot make start # launch now make stop # stop it make status # check status make disable # disable autostart make clean # remove the service Note that in order for the web ui to work properly you have to run make install once in the /home/pi/cinemate folder, even if you are not using the autostart service. storage-automount.service # storage-automount is a systemd service that watches for removable drives and mounts them automatically. The accompanying Python script reacts to udev events and the CFE-HAT eject button so drives can be attached or detached safely. It understands ext4 , ntfs and exfat filesystems. Partitions labelled RAW are mounted at /media/RAW ; any other label is mounted under /media/<LABEL> after sanitising the name. This applies to USB SSDs, NVMe drives and the CFE-HAT slot. To manually install and enable the service: cd cinemate/services/storage-automount sudo make install sudo make enable You can stop or disable it later with: sudo make stop sudo make disable wifi-hotspot.service # wifi-hotspot keeps a small access point running with the help of NetworkManager so you can always reach the web interface. The SSID and password are read from /home/pi/cinemate/src/settings.json under system.wifi_hotspot . Install and enable it with: cd cinemate/services/wifi-hotspot sudo make install sudo make enable As with storage-automount , you can stop or disable the hotspot with make stop and make disable .","title":"System services"},{"location":"system-services/#system-services","text":"","title":"System services"},{"location":"system-services/#cinemate-autostartservice","text":"make install # copy service file make enable # start on boot make start # launch now make stop # stop it make status # check status make disable # disable autostart make clean # remove the service Note that in order for the web ui to work properly you have to run make install once in the /home/pi/cinemate folder, even if you are not using the autostart service.","title":"cinemate-autostart.service"},{"location":"system-services/#storage-automountservice","text":"storage-automount is a systemd service that watches for removable drives and mounts them automatically. The accompanying Python script reacts to udev events and the CFE-HAT eject button so drives can be attached or detached safely. It understands ext4 , ntfs and exfat filesystems. Partitions labelled RAW are mounted at /media/RAW ; any other label is mounted under /media/<LABEL> after sanitising the name. This applies to USB SSDs, NVMe drives and the CFE-HAT slot. To manually install and enable the service: cd cinemate/services/storage-automount sudo make install sudo make enable You can stop or disable it later with: sudo make stop sudo make disable","title":"storage-automount.service"},{"location":"system-services/#wifi-hotspotservice","text":"wifi-hotspot keeps a small access point running with the help of NetworkManager so you can always reach the web interface. The SSID and password are read from /home/pi/cinemate/src/settings.json under system.wifi_hotspot . Install and enable it with: cd cinemate/services/wifi-hotspot sudo make install sudo make enable As with storage-automount , you can stop or disable the hotspot with make stop and make disable .","title":"wifi-hotspot.service"},{"location":"todo/","text":"Todo # simple_gui.py adaptive layout for non 1920x1080 screens 16 bit modes for imx585 support for imx294 overclocking of ISP optional auto-exposure hardware sync of sensor frame capture, perhaps via a pico rendering mode, for creating proxy files in camera (using https://github.com/mrjulesfletcher/dng_to_video) automatic detection of attached sensor and dynamic dtoverlay","title":"Todo"},{"location":"todo/#todo","text":"simple_gui.py adaptive layout for non 1920x1080 screens 16 bit modes for imx585 support for imx294 overclocking of ISP optional auto-exposure hardware sync of sensor frame capture, perhaps via a pico rendering mode, for creating proxy files in camera (using https://github.com/mrjulesfletcher/dng_to_video) automatic detection of attached sensor and dynamic dtoverlay","title":"Todo"},{"location":"troubleshooting/","text":"","title":"Troubleshooting"},{"location":"web-gui/","text":"TBA","title":"Web GUI"}]}